Yep—that explains it. You’re storing **`historical_stock_data.date` as `TIMESTAMPTZ`**, but most of your range logic now uses **`"YYYY-MM-DD"` strings**. Somewhere in that path a helper still does `.toISOString()` on a value that isn’t a `Date`, and boom.

Here’s a clean way to fix it and make this class of bug impossible going forward.

# Fix the range math (DB + server)

## Option A — Keep `TIMESTAMPTZ` (recommended) and use **Date params** (no strings)

**SQL (parameterized, end-exclusive):**

```sql
SELECT symbol, date, open, high, low, close, volume
FROM historical_stock_data
WHERE symbol = $1
  AND date >= $2::timestamptz
  AND date <  $3::timestamptz
ORDER BY date ASC;
```

**Server (build true UTC bounds and pass JS Dates):**

```ts
function utcStartOfDay(d: Date) {
  return new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
}
function addDaysUTC(d: Date, n: number) {
  const x = new Date(d.getTime()); x.setUTCDate(x.getUTCDate() + n); return x;
}

// window = '7D' | '30D' | '90D'
const todayUTC = utcStartOfDay(new Date());
const days = window === '7D' ? 7 : window === '30D' ? 30 : 90;
const startTs = addDaysUTC(todayUTC, -days);
const endTs   = addDaysUTC(todayUTC,  1);      // end-exclusive, includes “today”

const rows = await db.query(sql`
  SELECT symbol, date, open, high, low, close, volume
  FROM historical_stock_data
  WHERE symbol = ${symbol}
    AND date >= ${startTs}::timestamptz
    AND date <  ${endTs}::timestamptz
  ORDER BY date ASC
`);
```

> Key points:
>
> * **No `.toISOString()` anywhere** in the query path.
> * Pass **`Date` objects** to `pg`; it serializes safely.
> * **End-exclusive** avoids off-by-one midnight issues.

## Option B — If you’d rather compare on a **DATE** (no timezones)

Keep the `TIMESTAMPTZ` column, but compare via a generated **UTC date**:

**One-time migration (non-destructive):**

```sql
-- Optional: clarify the timestamp name
-- ALTER TABLE historical_stock_data RENAME COLUMN date TO ts_utc;

-- Add a computed UTC date (Postgres 12+)
ALTER TABLE historical_stock_data
ADD COLUMN day_utc date
GENERATED ALWAYS AS ( (date AT TIME ZONE 'UTC')::date ) STORED;

CREATE INDEX idx_hsd_day_utc_symbol ON historical_stock_data (day_utc, symbol);
```

**Query:**

```sql
SELECT symbol, date, open, high, low, close, volume
FROM historical_stock_data
WHERE symbol = $1
  AND day_utc BETWEEN $2::date AND $3::date
ORDER BY date ASC;
```

> This lets you keep windows in **`YYYY-MM-DD`** strings if you prefer—but you won’t call `.toISOString()` anywhere.

# Stop the `.toISOString()` crash everywhere

Add/keep a tiny helper and use it anywhere you format dates:

```ts
// shared/dates.ts
export function isoDate(value: unknown): string | null {
  if (value == null) return null;
  if (typeof value === 'string') return /^\d{4}-\d{2}-\d{2}/.test(value) ? value.slice(0,10)
                                                       : (new Date(value).toISOString().slice(0,10));
  if (value instanceof Date) return value.toISOString().slice(0,10);
  if (typeof value === 'number') return new Date(value).toISOString().slice(0,10);
  return null;
}
```

Then **grep** for `toISOString(` and replace untyped uses with `isoDate(...) ?? ''`.

# Make charts immune to date type wobbles

Return both a **string date** and a **numeric timestamp**:

```ts
// after selecting from DB
const series = rows.map(r => {
  const ms = new Date(r.date).getTime(); // r.date is a JS Date from pg for timestamptz
  return { date: isoDate(r.date)!, t: ms, close: Number(r.close) };
});
res.json({ success: true, data: series });
```

In Recharts:

```tsx
<XAxis dataKey="t" type="number" domain={['dataMin','dataMax']}
       tickFormatter={(ms) => new Date(ms).toLocaleDateString()} />
<Line dataKey="close" />
```

# Quick validation

* `SELECT pg_typeof(date) FROM historical_stock_data LIMIT 1;` → should say `timestamptz`.
* Hit your history endpoint; log `typeof startTs`/`endTs` (should be `object` (Date), not string).
* Console should no longer show “`toISOString is not a function`”.
* X-axis dates look correct; 7D/30D/90D change point counts as expected.

---

If you tell me which path you prefer (A: keep `TIMESTAMPTZ` with Date params, or B: add `day_utc` and compare on DATE), I’ll write the exact Drizzle migration + controller diff for your repo.
