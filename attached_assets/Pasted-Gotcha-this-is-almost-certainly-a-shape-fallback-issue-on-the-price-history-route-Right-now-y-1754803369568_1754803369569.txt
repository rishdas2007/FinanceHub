Gotcha—this is almost certainly a **shape + fallback** issue on the price-history route. Right now your modal is getting either `{ error: "Data not found" }` or a payload whose keys don’t match what the chart expects, so nothing renders.

Here’s the quickest way to make it load reliably again:

---

# 1) Make the history API **always return the same shape** (and never “error”)

**server/controllers/price-history.ts**

```ts
app.get('/api/stocks/:symbol/history', async (req, res) => {
  const symbol = String(req.params.symbol || '').toUpperCase();
  const window = String(req.query.window || '90D').toUpperCase(); // '7D'|'30D'|'90D'

  // daily bars for these windows; compute dates in UTC
  const { startISO, endISO } = computeUtcDateRange(window);
  const interval = '1day';

  try {
    const raw = await twelveData.timeSeries({
      symbol,
      interval,
      start_date: startISO,   // 'YYYY-MM-DD' (UTC)
      end_date: endISO,
      outputsize: 1000,
      // exchange: 'ARCA', // uncomment if your provider needs it for ETFs
      // adjusted: true,
      timeout: 7000,          // if your client supports AbortController or axios timeout
    });

    const rows = normalizeTwelveData(raw); // → [{ timestamp:'YYYY-MM-DD', close:number }]
    return res.json({ success: true, data: rows });
  } catch (e:any) {
    console.error('HISTORY ERROR', symbol, e?.message);
    // Fail-soft contract: never throw, never `{error:...}`
    return res.json({ success: true, data: [] , warning: 'data_unavailable' });
  }
});

function computeUtcDateRange(window: string) {
  const d = new Date();
  const end = new Date(Date.UTC(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate()));
  const start = new Date(end);
  const days = window === '7D' ? 7 : window === '30D' ? 30 : 90;
  start.setUTCDate(start.getUTCDate() - days);
  const iso = (x: Date) => x.toISOString().slice(0,10);
  return { startISO: iso(start), endISO: iso(end) };
}

function normalizeTwelveData(raw: any) {
  const values = raw?.values ?? raw?.data ?? [];
  return values
    .map((v: any) => ({
      timestamp: (v.datetime || v.date || v.time)?.slice(0,10),
      close: Number(v.close ?? v.c ?? v.adj_close),
    }))
    .filter((r: any) => r.timestamp && Number.isFinite(r.close))
    .sort((a: any, b: any) => a.timestamp.localeCompare(b.timestamp));
}
```

**Why:** The UI can now depend on `{ success:true, data:[{timestamp, close}] }`. No more `{error:"Data not found"}`.

---

# 2) Harden the client queryFn to treat provider errors as **empty series**

**client/src/lib/queryClient.ts**

```ts
// after JSON parse:
if (json && (json.error || json.code === 400 || json.status === 'error')) {
  return []; // treat provider errors as empty data
}

const unwrapped =
  Array.isArray(json) ? json :
  json?.data ?? json?.metrics ?? json?.results ?? json?.items ?? json?.rows ?? json;

return unwrapped;
```

---

# 3) Normalize the series on the client before rendering

In your modal component (or a tiny util), adapt whatever comes back to the chart’s keys:

```ts
function toChartSeries(input: any): { date: string; price: number }[] {
  const arr = Array.isArray(input) ? input : [];
  return arr
    .map((r: any) => ({
      date: r.timestamp || r.datetime || r.date || r.t,
      price: Number(r.close ?? r.price ?? r.c ?? r.adjClose),
    }))
    .filter((r) => r.date && Number.isFinite(r.price));
}

// usage
const raw = data ?? [];
const series = toChartSeries(raw);
```

And in your chart:

```tsx
<XAxis dataKey="date" tickFormatter={(iso) => new Date(iso).toLocaleDateString()} />
<Line dataKey="price" /* ... */ />
```

---

# 4) Make the modal bullet-proof (no blank canvas)

```tsx
if (!series.length) {
  return (
    <EmptyState
      title="No data for this range"
      subtitle="Source returned no bars. Try 90D or another symbol."
    />
  );
}
```

---

# 5) Quick smoke checks

* **Network →** `/api/stocks/XLK/history?window=30D` should now return:

  ```json
  { "success": true, "data": [ { "timestamp": "2025-07-12", "close": 263.51 }, ... ] }
  ```
* Flip 7D/30D/90D: point counts should change; axis dates should be distinct.
* **CSV** should download actual rows (not `{"error":...}`).

---

## If it’s still blank, check these two gotchas

1. **Bad URL composition**
   Your query should be like:

```ts
useQuery({ queryKey: [`/api/stocks/${symbol}/history`, { window }] })
```

If you’re still using `queryKey: [ '/api/stocks/history', { symbol, window } ]` but the server expects the **symbol in the path**, you’ll hit a 404. Either switch to the path form above or change the server route to accept query `symbol=`.

2. **Provider ETF quirk**
   Some providers need `exchange=ARCA` for XLK/sector ETFs. If your response body contains `"Data not found"` for XLK but works for XLF, set `exchange:'ARCA'` (or whatever your provider requires) in the server call.

---

Want me to draft a tiny PR-style diff for these four changes (server route, queryFn, series normalizer, modal empty state)? If you paste the raw response from `/api/stocks/XLK/history?window=30D`, I’ll tailor the normalizer to your provider’s exact fields.
