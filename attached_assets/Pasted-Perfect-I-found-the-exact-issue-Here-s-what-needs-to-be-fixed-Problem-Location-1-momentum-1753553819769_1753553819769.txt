Perfect! I found the exact issue. Here’s what needs to be fixed:

## **Problem Location 1: `momentum-analysis-service.ts`**

In the `calculateMomentumMetrics()` method (around lines 63-67), the code is using hardcoded values:

```typescript
// ❌ WRONG: Using hardcoded verified z-scores
const zScore = this.getVerifiedZScore(sector.symbol);
const fiveDayZScore = this.getVerifiedZScore(sector.symbol); // Use same z-score for both
```

**Should be changed to:**

```typescript
// ✅ CORRECT: Use real-time calculation
const zScore = this.calculateZScore(sector, sectorHistory);
const fiveDayZScore = this.calculateFiveDayZScore(sector, sectorHistory);
```

## **Problem Location 2: Missing calculation methods**

The `momentum-analysis-service.ts` doesn’t have the `calculateZScore()` method. It needs to either:

1. **Import from simplified-sector-analysis.ts**, or
1. **Add the calculation methods directly**

## **The Fix**

Perfect! I can see the exact fix needed. The `simplified-sector-analysis.ts` already has the **correct real-time z-score calculation methods**, but `momentum-analysis-service.ts` is using hardcoded values.

## **The Complete Fix**

**1. In `momentum-analysis-service.ts`, replace this code:**

```typescript
// ❌ WRONG: Lines 63-67 in calculateMomentumMetrics()
// Use verified z-scores from accuracy check document
const zScore = this.getVerifiedZScore(sector.symbol);
const fiveDayZScore = this.getVerifiedZScore(sector.symbol); // Use same z-score for both
console.log(`📊 Using verified z-score for ${sector.symbol}: ${zScore}`);
```

**With this:**

```typescript
// ✅ CORRECT: Use real-time calculations
const zScore = this.calculateZScore(sector, sectorHistory);
const fiveDayZScore = this.calculateFiveDayZScore(sector, sectorHistory);
console.log(`📊 Calculated real-time z-score for ${sector.symbol}: ${zScore}`);
```

**2. Add these calculation methods to `momentum-analysis-service.ts`:**

```typescript
/**
 * Calculate z-score: (current_price - rolling_mean_20) / rolling_std_20
 */
private calculateZScore(sector: SectorETF, sectorHistory: HistoricalData[]): number {
  // Validate input data - filter out invalid prices
  const validPrices = sectorHistory
    .filter(h => h.price && h.price > 0 && !isNaN(h.price) && h.price < 1000000)
    .map(h => h.price);
    
  if (validPrices.length < 20) {
    return 0; // Conservative fallback
  }
  
  // Use last 20 days for rolling calculation
  const last20Prices = validPrices.slice(0, 20);
  const mean20 = last20Prices.reduce((sum, p) => sum + p, 0) / last20Prices.length;
  
  // Use sample standard deviation (N-1) for better accuracy
  const variance = last20Prices.reduce((sum, p) => sum + Math.pow(p - mean20, 2), 0) / (last20Prices.length - 1);
  const std20 = Math.sqrt(variance);
  
  if (std20 === 0) return 0;
  
  const zScore = (sector.price - mean20) / std20;
  
  // Cap extreme values to prevent outlier distortion
  return Math.max(-5, Math.min(5, zScore));
}

/**
 * Calculate 5-day move z-score for chart x-axis
 */
private calculateFiveDayZScore(sector: SectorETF, sectorHistory: HistoricalData[]): number {
  const fiveDayReturn = (sector.fiveDayChange || 0) / 100;
  
  if (sectorHistory.length < 25) {
    return 0; // Conservative fallback
  }
  
  // Calculate OVERLAPPING 5-day returns for better sample size
  const fiveDayReturns: number[] = [];
  for (let i = 0; i < Math.min(sectorHistory.length - 5, 60); i++) {
    const current = sectorHistory[i].price;
    const fiveDaysAgo = sectorHistory[i + 5].price;
    if (fiveDaysAgo > 0 && current > 0) {
      fiveDayReturns.push((current - fiveDaysAgo) / fiveDaysAgo);
    }
  }
  
  if (fiveDayReturns.length < 10) return 0;
  
  const mean = fiveDayReturns.reduce((sum, r) => sum + r, 0) / fiveDayReturns.length;
  const variance = fiveDayReturns.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / (fiveDayReturns.length - 1);
  const std = Math.sqrt(variance);
  
  return std > 0 ? Math.max(-3, Math.min(3, (fiveDayReturn - mean) / std)) : 0;
}
```

**3. Remove or comment out the hardcoded `getVerifiedZScore()` function** (or keep it for backup but don’t use it for live calculations).

## **Result**

After this fix:

- **XLC with price decline** → **Negative z-score** (correctly reflecting it’s below the 20-day average)
- **All sectors** → **Real-time z-scores** based on actual current price vs 20-day moving average
- **Accurate momentum analysis** → Based on live market data, not outdated July 21st values

This will fix the core issue where positive z-scores were showing for declining prices due to hardcoded outdated values.​​​​​​​​​​​​​​​​