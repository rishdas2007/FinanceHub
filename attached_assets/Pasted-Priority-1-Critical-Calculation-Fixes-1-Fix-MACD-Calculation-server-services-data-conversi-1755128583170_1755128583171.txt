Priority 1: Critical Calculation Fixes

  1. Fix MACD Calculation -
  /server/services/data-conversion-service.ts:213-226
    - Implement proper signal line calculation (9-period EMA of MACD line)
    - Add MACD histogram calculation
    - Ensure 12/26 period EMAs match standard calculations
  2. Fix RSI Calculation -
  /server/services/data-conversion-service.ts:193-211
    - Implement Wilder's exponential smoothing method
    - Use proper 14-period lookback with exponential weighting
    - Validate against standard RSI formula
  3. Fix Bollinger %B Calculation -
  /server/services/data-conversion-service.ts:257
    - Change variance calculation from population to sample variance
    - Update line 257: / (period - 1) instead of / period

  Priority 2: Z-Score Standardization

  4. Standardize Z-Score Parameters -
  /server/services/zscore-technical-service.ts:67-73
    - Use standard calculation windows: MACD (26), RSI (14), Bollinger (20)
    - Remove custom multi-horizon windows for dashboard display
    - Align with industry standard parameters
  5. Fix Z-Score Display Logic - /client/src/components/ETFMetricsTable.tsx
    - Ensure dashboard displays actual calculated values, not Z-scores
    - Show raw MACD values in MACD column, Z-scores in separate Z-Score
  column

  Priority 3: Data Quality Improvements

  6. Improve Data Freshness - /server/services/etf-metrics-service.ts:276
    - Reduce lookback from 7 days to 1-2 days for technical indicators
    - Add data timestamp validation
    - Implement data quality checks before calculation
  7. Add Calculation Verification
    - Create unit tests comparing calculations against known values
    - Add logging to track when fallback data is used
    - Implement data source provenance tracking

⏺ Update Todos
  ⎿  ☒ Examine the codebase structure in financehub_pro_v21_complete
     ☒ Locate ETF technical metrics calculation code
     ☒ Identify data sources and calculation parameters
     ☒ Compare calculation logic with standard formulas
     ☒ Identify root cause of discrepancies
     ☒ Create fix plan with specific changes needed

⏺ Implementation Estimate

  - Critical fixes: 2-3 hours
  - Z-score standardization: 1-2 hours
  - Data quality improvements: 2-4 hours
  - Testing and validation: 1-2 hours

  Total effort: 6-11 hours

  The discrepancies in your dashboard stem from calculation errors in core
  technical indicators and confusion between raw indicator values and their
   Z-score normalizations. The fixes above will align your calculations
  with standard financial analysis practices and match the verified values
  you provided.

> Can you put a detailed implementation plan together (with code updates) 
  for my Replit AI agent to implement?

⏺ Detailed Implementation Plan: ETF Technical Metrics Dashboard Fix

  Overview

  Fix critical calculation errors in MACD, RSI, Bollinger %B, and Z-score
  display logic to align with standard financial analysis practices.

  Phase 1: Critical Calculation Fixes (Priority 1)

  1.1 Fix MACD Calculation

  File: /server/services/data-conversion-service.ts
  Lines: 213-226

  Current Issue:
  private calculateMACD(closes: number[]): { macd: number | null; signal:
  number | null } {
    // Need at least 52 data points for proper MACD (26*2 for EMA seeding)
    if (closes.length < 52) return { macd: null, signal: null };

    const ema12 = this.calculateEMA(closes, 12);
    const ema26 = this.calculateEMA(closes, 26);

    if (!ema12 || !ema26) return { macd: null, signal: null };

    const macd = ema12 - ema26;

    // For signal line, we'd need MACD history - simplified here
    return { macd, signal: null };
  }

  Fixed Implementation:
  private calculateMACD(closes: number[]): {
    macd: number | null;
    signal: number | null;
    histogram: number | null;
  } {
    // Need at least 52 data points for proper MACD (26*2 for EMA seeding +
   9 for signal)
    if (closes.length < 61) return { macd: null, signal: null, histogram:
  null };

    // Calculate EMAs for each data point to build MACD history
    const macdHistory: number[] = [];

    // Start from index 26 to have sufficient EMA history
    for (let i = 26; i < closes.length; i++) {
      const windowData = closes.slice(0, i + 1);
      const ema12 = this.calculateEMA(windowData, 12);
      const ema26 = this.calculateEMA(windowData, 26);

      if (ema12 && ema26) {
        macdHistory.push(ema12 - ema26);
      }
    }

    if (macdHistory.length < 9) return { macd: null, signal: null,
  histogram: null };

    const currentMacd = macdHistory[macdHistory.length - 1];

    // Calculate 9-period EMA of MACD line for signal
    const signal = this.calculateEMA(macdHistory, 9);

    const histogram = signal ? currentMacd - signal : null;

    return {
      macd: currentMacd,
      signal,
      histogram
    };
  }

  Update return structure in calculateTechnicalIndicators (line 169):
  // MACD (12, 26, 9) - Fixed periods for accurate calculation
  const { macd, signal, histogram } = this.calculateMACD(closes);

  return {
    rsi: rsi ? rsi.toFixed(2) : null,
    macd: macd ? macd.toFixed(4) : null,
    macdSignal: signal ? signal.toFixed(4) : null,
    macdHistogram: histogram ? histogram.toFixed(4) : null,
    // ... rest of return object
  };

  1.2 Fix RSI Calculation

  File: /server/services/data-conversion-service.ts
  Lines: 193-211

  Current Issue:
  private calculateRSI(closes: number[], period: number = 14): number |
  null {
    if (closes.length < period + 1) return null;

    let gains = 0;
    let losses = 0;

    for (let i = closes.length - period; i < closes.length; i++) {
      const change = closes[i] - closes[i - 1];
      if (change > 0) gains += change;
      else losses += Math.abs(change);
    }

    const avgGain = gains / period;
    const avgLoss = losses / period;

    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  }

  Fixed Implementation (Wilder's Smoothing Method):
  private calculateRSI(closes: number[], period: number = 14): number |
  null {
    if (closes.length < period + 1) return null;

    const changes: number[] = [];
    for (let i = 1; i < closes.length; i++) {
      changes.push(closes[i] - closes[i - 1]);
    }

    if (changes.length < period) return null;

    // Initial averages for first period
    let avgGain = 0;
    let avgLoss = 0;

    for (let i = 0; i < period; i++) {
      const change = changes[i];
      if (change > 0) {
        avgGain += change;
      } else {
        avgLoss += Math.abs(change);
      }
    }

    avgGain /= period;
    avgLoss /= period;

    // Apply Wilder's smoothing for remaining periods
    for (let i = period; i < changes.length; i++) {
      const change = changes[i];
      const gain = change > 0 ? change : 0;
      const loss = change < 0 ? Math.abs(change) : 0;

      // Wilder's smoothing: ((previous avg * (period-1)) + current value) 
  / period
      avgGain = (avgGain * (period - 1) + gain) / period;
      avgLoss = (avgLoss * (period - 1) + loss) / period;
    }

    if (avgLoss === 0) return 100;

    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));

    // Ensure bounds [0, 100]
    return Math.max(0, Math.min(100, rsi));
  }

  1.3 Fix Bollinger %B Calculation

  File: /server/services/data-conversion-service.ts
  Lines: 245-271

  Current Issue (line 257):
  const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma, 2),
   0) / period;

  Fixed Implementation:
  private calculateBollingerBands(closes: number[], period: number = 20,
  multiplier: number = 2): {
    upper: number | null;
    middle: number | null;
    lower: number | null;
    percent_b: number | null;
  } {
    if (closes.length < period) {
      return { upper: null, middle: null, lower: null, percent_b: null };
    }

    const slice = closes.slice(-period);
    const sma = slice.reduce((sum, val) => sum + val, 0) / period;

    // FIX: Use sample variance (N-1) instead of population variance (N)
    const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma,
  2), 0) / (period - 1);
    const stdDev = Math.sqrt(variance);

    const upper = sma + (multiplier * stdDev);
    const lower = sma - (multiplier * stdDev);
    const currentPrice = closes[closes.length - 1];

    // Ensure valid %B calculation
    const bandWidth = upper - lower;
    const percent_b = bandWidth > 0 ? (currentPrice - lower) / bandWidth :
  0.5;

    return {
      upper,
      middle: sma,
      lower,
      percent_b: Math.max(0, Math.min(1, percent_b)) // Clamp to [0, 1] 
  range
    };
  }

  Phase 2: Z-Score Standardization (Priority 2)

  2.1 Create Standard Technical Indicators Service

  New File: /server/services/standard-technical-indicators.ts

  /**
   * Standard Technical Indicators Service
   * Implements industry-standard calculations for MACD(12,26,9), RSI(14), 
  Bollinger(20,2)
   */

  export interface StandardTechnicalIndicators {
    symbol: string;
    timestamp: Date;

    // Raw indicator values (not Z-scores)
    rsi: number | null;           // 14-period RSI
    macd: number | null;          // MACD line (EMA12 - EMA26)
    macdSignal: number | null;    // 9-period EMA of MACD
    macdHistogram: number | null; // MACD - Signal

    // Bollinger Bands (20, 2)
    bollingerUpper: number | null;
    bollingerMiddle: number | null;  // 20-period SMA
    bollingerLower: number | null;
    bollingerPercentB: number | null; // %B position

    // Z-scores (for advanced analysis only)
    rsiZScore: number | null;
    macdZScore: number | null;
    bollingerZScore: number | null;
  }

  export class StandardTechnicalIndicatorsService {
    private static instance: StandardTechnicalIndicatorsService;

    public static getInstance(): StandardTechnicalIndicatorsService {
      if (!this.instance) {
        this.instance = new StandardTechnicalIndicatorsService();
      }
      return this.instance;
    }

    /**
     * Calculate standard technical indicators for display
     */
    async calculateStandardIndicators(symbol: string):
  Promise<StandardTechnicalIndicators | null> {
      try {
        // Get 100 days of price data for reliable calculations
        const priceData = await this.getPriceHistory(symbol, 100);
        if (priceData.length < 50) return null;

        const closes = priceData.map(d => parseFloat(d.close));
        const highs = priceData.map(d => parseFloat(d.high));
        const lows = priceData.map(d => parseFloat(d.low));

        // Calculate standard indicators
        const rsi = this.calculateStandardRSI(closes, 14);
        const { macd, signal, histogram } =
  this.calculateStandardMACD(closes);
        const bollinger = this.calculateStandardBollinger(closes, 20, 2);

        // Calculate Z-scores using 60-day rolling window (standard for 
  daily data)
        const rsiZScore = this.calculateZScore(closes.map((_, i) =>
  this.calculateStandardRSI(closes.slice(0, i + 1), 14)).filter(v => v !==
  null), rsi, 60);
        const macdValues = closes.map((_, i) => {
          const result = this.calculateStandardMACD(closes.slice(0, i +
  1));
          return result.macd;
        }).filter(v => v !== null);
        const macdZScore = this.calculateZScore(macdValues, macd, 60);
        const bollingerZScore = this.calculateZScore(closes.map((_, i) =>
  this.calculateStandardBollinger(closes.slice(0, i + 1), 20,
  2).percent_b).filter(v => v !== null), bollinger.percent_b, 60);

        return {
          symbol,
          timestamp: new Date(),

          // Raw values for dashboard display
          rsi,
          macd,
          macdSignal: signal,
          macdHistogram: histogram,

          bollingerUpper: bollinger.upper,
          bollingerMiddle: bollinger.middle,
          bollingerLower: bollinger.lower,
          bollingerPercentB: bollinger.percent_b,

          // Z-scores for advanced analysis
          rsiZScore,
          macdZScore,
          bollingerZScore
        };

      } catch (error) {
        console.error(`Error calculating standard indicators for 
  ${symbol}:`, error);
        return null;
      }
    }

    private calculateZScore(historicalValues: number[], currentValue:
  number | null, window: number): number | null {
      if (!currentValue || historicalValues.length < window) return null;

      const recentValues = historicalValues.slice(-window);
      const mean = recentValues.reduce((sum, val) => sum + val, 0) /
  recentValues.length;
      const variance = recentValues.reduce((sum, val) => sum + Math.pow(val
   - mean, 2), 0) / (recentValues.length - 1);
      const stdDev = Math.sqrt(variance);

      return stdDev > 1e-8 ? (currentValue - mean) / stdDev : 0;
    }

    // Use the corrected calculation methods from Phase 1
    private calculateStandardRSI = /* Copy fixed RSI method from Phase 1 
  */;
    private calculateStandardMACD = /* Copy fixed MACD method from Phase 1 
  */;
    private calculateStandardBollinger = /* Copy fixed Bollinger method 
  from Phase 1 */;
  }

  2.2 Update ETF Metrics Service Integration

  File: /server/services/etf-metrics-service.ts
  Lines: 196-214 (database fetching section)

  Add import:
  import { StandardTechnicalIndicatorsService } from
  './standard-technical-indicators';

  Replace technical indicators fetching (around line 198):
  // 5. OPTIMIZED: Use standard technical indicators instead of database 
  fallbacks
  const standardTechService =
  StandardTechnicalIndicatorsService.getInstance();
  const standardIndicators = await Promise.all(
    this.ETF_SYMBOLS.map(async (symbol) => {
      const indicators = await
  standardTechService.calculateStandardIndicators(symbol);
      return [symbol, indicators];
    })
  );
  const dbTechnicals = new Map(standardIndicators);

  Phase 3: Dashboard Display Fixes (Priority 2)

  3.1 Update ETF Metrics Table Component

  File: /client/src/components/ETFMetricsTable.tsx
  Lines: 54-79 (ETFMetrics interface)

  Updated Interface:
  interface ETFMetrics {
    symbol: string;
    name: string;
    price: number;
    changePercent: number;

    // CLEAR SEPARATION: Raw technical indicators for display
    technicalIndicators: {
      rsi: number | null;                    // Actual RSI value (0-100)
      macd: number | null;                   // Actual MACD line value
      macdSignal: number | null;             // MACD signal line
      macdHistogram: number | null;          // MACD histogram
      bollingerPercentB: number | null;      // Actual %B value (0-1)
      bollingerUpper: number | null;
      bollingerLower: number | null;
    };

    // SEPARATE: Z-Score analysis (advanced metrics)
    zScoreAnalysis: {
      rsiZScore: number | null;
      macdZScore: number | null;
      bollingerZScore: number | null;
      compositeZScore: number | null;
      signal: 'BUY' | 'SELL' | 'HOLD';
    } | null;

    // Other existing fields...
    maSignal: string;
    maTrend: 'bullish' | 'bearish' | 'neutral';
    maGap: number | null;
  }

  3.2 Update Table Display Logic

  File: /client/src/components/ETFMetricsTable.tsx
  Around lines 200-300 (table cells)

  Replace MACD display:
  {/* MACD Column - Show actual MACD value, not Z-score */}
  <td className="px-2 py-1 text-xs text-center">
    <div className="flex flex-col items-center gap-0.5">
      <span className={`font-medium ${
        etf.technicalIndicators?.macd && etf.technicalIndicators.macd > 0
          ? 'text-green-400'
          : 'text-red-400'
      }`}>
        {etf.technicalIndicators?.macd?.toFixed(3) || 'N/A'}
      </span>
      {etf.zScoreAnalysis?.macdZScore && (
        <span className="text-xs text-gray-400">
          Z: {etf.zScoreAnalysis.macdZScore.toFixed(2)}
        </span>
      )}
    </div>
  </td>

  Replace RSI display:
  {/* RSI Column - Show actual RSI value (0-100) */}
  <td className="px-2 py-1 text-xs text-center">
    <div className="flex flex-col items-center gap-0.5">
      <span className={`font-medium ${
        etf.technicalIndicators?.rsi 
          ? etf.technicalIndicators.rsi > 70 ? 'text-red-400'
            : etf.technicalIndicators.rsi < 30 ? 'text-green-400'
            : 'text-blue-400'
          : 'text-gray-400'
      }`}>
        {etf.technicalIndicators?.rsi?.toFixed(1) || 'N/A'}
      </span>
      {etf.zScoreAnalysis?.rsiZScore && (
        <span className="text-xs text-gray-400">
          Z: {etf.zScoreAnalysis.rsiZScore.toFixed(2)}
        </span>
      )}
    </div>
  </td>

  Replace %B display:
  {/* %B Column - Show actual %B percentage */}
  <td className="px-2 py-1 text-xs text-center">
    <div className="flex flex-col items-center gap-0.5">
      <span className={`font-medium ${
        etf.technicalIndicators?.bollingerPercentB 
          ? etf.technicalIndicators.bollingerPercentB > 0.8 ?
  'text-red-400'
            : etf.technicalIndicators.bollingerPercentB < 0.2 ?
  'text-green-400'
            : 'text-blue-400'
          : 'text-gray-400'
      }`}>
        {etf.technicalIndicators?.bollingerPercentB
          ? `${(etf.technicalIndicators.bollingerPercentB *
  100).toFixed(1)}%`
          : 'N/A'
        }
      </span>
      {etf.zScoreAnalysis?.bollingerZScore && (
        <span className="text-xs text-gray-400">
          Z: {etf.zScoreAnalysis.bollingerZScore.toFixed(2)}
        </span>
      )}
    </div>
  </td>

  Phase 4: Data Quality & Validation (Priority 3)

  4.1 Add Calculation Validation Tests

  New File: /tests/unit/services/technical-indicators.test.ts

  import { describe, it, expect } from 'vitest';
  import { StandardTechnicalIndicatorsService } from
  '../../../server/services/standard-technical-indicators';

  describe('Technical Indicators Validation', () => {
    const service = StandardTechnicalIndicatorsService.getInstance();

    // Test data: SPY prices for known RSI/MACD values
    const testPrices = [
      // Add known price sequence with verified RSI/MACD values
      440.50, 441.20, 442.10, 441.80, 440.90, // ... add more
    ];

    it('should calculate RSI correctly', () => {
      const rsi = service.calculateStandardRSI(testPrices, 14);
      expect(rsi).toBeCloseTo(60.2, 1); // Expected RSI from your 
  verification
    });

    it('should calculate MACD correctly', () => {
      const { macd } = service.calculateStandardMACD(testPrices);
      expect(macd).toBeCloseTo(5.95, 2); // Expected MACD from your 
  verification
    });

    it('should calculate Bollinger %B correctly', () => {
      const bollinger = service.calculateStandardBollinger(testPrices, 20,
  2);
      expect(bollinger.percent_b).toBeCloseTo(1.043, 3); // Expected %B 
  from your verification
    });
  });

  4.2 Add Data Freshness Monitoring

  File: /server/services/etf-metrics-service.ts
  Lines: 274-311 (getLatestPricesFromDB method)

  Update data freshness check:
  private async getLatestPricesFromDB() {
    const results = new Map();

    // IMPROVED: Reduce lookback to 2 days for fresher data
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 2);

    for (const symbol of this.ETF_SYMBOLS) {
      try {
        const latest = await db
          .select()
          .from(stockData)
          .where(and(
            eq(stockData.symbol, symbol),
            gte(stockData.timestamp, cutoffDate)
          ))
          .orderBy(desc(stockData.timestamp))
          .limit(1);

        if (latest.length > 0) {
          const priceData = latest[0];
          const price = parseFloat(priceData.price);
          const dataAge = Date.now() - priceData.timestamp.getTime();
          const hoursOld = dataAge / (1000 * 60 * 60);

          // VALIDATION: Ensure price sanity and freshness
          if (price > 0 && isFinite(price) && hoursOld < 48) {
            results.set(symbol, { ...priceData, close: price, ts:
  priceData.timestamp });
            logger.info(`💰 Fresh price for ${symbol}: $${price} 
  (${hoursOld.toFixed(1)}h old)`);
          } else {
            logger.warn(`🚨 Stale/invalid price data for ${symbol}: 
  $${price}, ${hoursOld.toFixed(1)}h old`);
          }
        }
      } catch (error) {
        logger.warn(`No price data for ${symbol}:`, error);
      }
    }

    return results;
  }

  Implementation Timeline

  Day 1 (4-6 hours)

  1. Phase 1.1-1.3: Fix MACD, RSI, Bollinger calculations
  2. Phase 2.1: Create StandardTechnicalIndicatorsService
  3. Test: Verify calculations match expected values

  Day 2 (3-4 hours)

  1. Phase 2.2: Integrate standard service into ETF metrics
  2. Phase 3.1-3.2: Update dashboard display logic
  3. Test: Verify dashboard shows correct values

  Day 3 (2-3 hours)

  1. Phase 4.1-4.2: Add validation tests and monitoring
  2. Deploy: Test in production environment
  3. Verify: Compare dashboard values with your verification data

  Success Criteria

  After implementation, your dashboard should show:
  - RSI: Values matching standard 14-period calculations (~60.2 for SPY)
  - MACD: Values matching standard 12,26,9 calculations (~5.95 for SPY)
  - %B: Values matching standard 20,2 calculations (~104.3% for SPY)
  - Z-scores: Displayed separately from raw indicator values
  - Data freshness: Indicators based on recent price data (< 48 hours old)

  This plan addresses all the discrepancies identified in your comparison
  table and aligns your calculations with industry standards.