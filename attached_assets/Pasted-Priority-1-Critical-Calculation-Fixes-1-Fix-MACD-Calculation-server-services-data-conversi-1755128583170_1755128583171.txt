Priority 1: Critical Calculation Fixes

  1. Fix MACD Calculation -
  /server/services/data-conversion-service.ts:213-226
    - Implement proper signal line calculation (9-period EMA of MACD line)
    - Add MACD histogram calculation
    - Ensure 12/26 period EMAs match standard calculations
  2. Fix RSI Calculation -
  /server/services/data-conversion-service.ts:193-211
    - Implement Wilder's exponential smoothing method
    - Use proper 14-period lookback with exponential weighting
    - Validate against standard RSI formula
  3. Fix Bollinger %B Calculation -
  /server/services/data-conversion-service.ts:257
    - Change variance calculation from population to sample variance
    - Update line 257: / (period - 1) instead of / period

  Priority 2: Z-Score Standardization

  4. Standardize Z-Score Parameters -
  /server/services/zscore-technical-service.ts:67-73
    - Use standard calculation windows: MACD (26), RSI (14), Bollinger (20)
    - Remove custom multi-horizon windows for dashboard display
    - Align with industry standard parameters
  5. Fix Z-Score Display Logic - /client/src/components/ETFMetricsTable.tsx
    - Ensure dashboard displays actual calculated values, not Z-scores
    - Show raw MACD values in MACD column, Z-scores in separate Z-Score
  column

  Priority 3: Data Quality Improvements

  6. Improve Data Freshness - /server/services/etf-metrics-service.ts:276
    - Reduce lookback from 7 days to 1-2 days for technical indicators
    - Add data timestamp validation
    - Implement data quality checks before calculation
  7. Add Calculation Verification
    - Create unit tests comparing calculations against known values
    - Add logging to track when fallback data is used
    - Implement data source provenance tracking

‚è∫ Update Todos
  ‚éø ¬†‚òí Examine the codebase structure in financehub_pro_v21_complete
     ‚òí Locate ETF technical metrics calculation code
     ‚òí Identify data sources and calculation parameters
     ‚òí Compare calculation logic with standard formulas
     ‚òí Identify root cause of discrepancies
     ‚òí Create fix plan with specific changes needed

‚è∫ Implementation Estimate

  - Critical fixes: 2-3 hours
  - Z-score standardization: 1-2 hours
  - Data quality improvements: 2-4 hours
  - Testing and validation: 1-2 hours

  Total effort: 6-11 hours

  The discrepancies in your dashboard stem from calculation errors in core
  technical indicators and confusion between raw indicator values and their
   Z-score normalizations. The fixes above will align your calculations
  with standard financial analysis practices and match the verified values
  you provided.

> Can you put a detailed implementation plan together (with code updates) 
  for my Replit AI agent to implement?

‚è∫ Detailed Implementation Plan: ETF Technical Metrics Dashboard Fix

  Overview

  Fix critical calculation errors in MACD, RSI, Bollinger %B, and Z-score
  display logic to align with standard financial analysis practices.

  Phase 1: Critical Calculation Fixes (Priority 1)

  1.1 Fix MACD Calculation

  File: /server/services/data-conversion-service.ts
  Lines: 213-226

  Current Issue:
  private calculateMACD(closes: number[]): { macd: number | null; signal:
  number | null } {
    // Need at least 52 data points for proper MACD (26*2 for EMA seeding)
    if (closes.length < 52) return { macd: null, signal: null };

    const ema12 = this.calculateEMA(closes, 12);
    const ema26 = this.calculateEMA(closes, 26);

    if (!ema12 || !ema26) return { macd: null, signal: null };

    const macd = ema12 - ema26;

    // For signal line, we'd need MACD history - simplified here
    return { macd, signal: null };
  }

  Fixed Implementation:
  private calculateMACD(closes: number[]): {
    macd: number | null;
    signal: number | null;
    histogram: number | null;
  } {
    // Need at least 52 data points for proper MACD (26*2 for EMA seeding +
   9 for signal)
    if (closes.length < 61) return { macd: null, signal: null, histogram:
  null };

    // Calculate EMAs for each data point to build MACD history
    const macdHistory: number[] = [];

    // Start from index 26 to have sufficient EMA history
    for (let i = 26; i < closes.length; i++) {
      const windowData = closes.slice(0, i + 1);
      const ema12 = this.calculateEMA(windowData, 12);
      const ema26 = this.calculateEMA(windowData, 26);

      if (ema12 && ema26) {
        macdHistory.push(ema12 - ema26);
      }
    }

    if (macdHistory.length < 9) return { macd: null, signal: null,
  histogram: null };

    const currentMacd = macdHistory[macdHistory.length - 1];

    // Calculate 9-period EMA of MACD line for signal
    const signal = this.calculateEMA(macdHistory, 9);

    const histogram = signal ? currentMacd - signal : null;

    return {
      macd: currentMacd,
      signal,
      histogram
    };
  }

  Update return structure in calculateTechnicalIndicators (line 169):
  // MACD (12, 26, 9) - Fixed periods for accurate calculation
  const { macd, signal, histogram } = this.calculateMACD(closes);

  return {
    rsi: rsi ? rsi.toFixed(2) : null,
    macd: macd ? macd.toFixed(4) : null,
    macdSignal: signal ? signal.toFixed(4) : null,
    macdHistogram: histogram ? histogram.toFixed(4) : null,
    // ... rest of return object
  };

  1.2 Fix RSI Calculation

  File: /server/services/data-conversion-service.ts
  Lines: 193-211

  Current Issue:
  private calculateRSI(closes: number[], period: number = 14): number |
  null {
    if (closes.length < period + 1) return null;

    let gains = 0;
    let losses = 0;

    for (let i = closes.length - period; i < closes.length; i++) {
      const change = closes[i] - closes[i - 1];
      if (change > 0) gains += change;
      else losses += Math.abs(change);
    }

    const avgGain = gains / period;
    const avgLoss = losses / period;

    if (avgLoss === 0) return 100;
    const rs = avgGain / avgLoss;
    return 100 - (100 / (1 + rs));
  }

  Fixed Implementation (Wilder's Smoothing Method):
  private calculateRSI(closes: number[], period: number = 14): number |
  null {
    if (closes.length < period + 1) return null;

    const changes: number[] = [];
    for (let i = 1; i < closes.length; i++) {
      changes.push(closes[i] - closes[i - 1]);
    }

    if (changes.length < period) return null;

    // Initial averages for first period
    let avgGain = 0;
    let avgLoss = 0;

    for (let i = 0; i < period; i++) {
      const change = changes[i];
      if (change > 0) {
        avgGain += change;
      } else {
        avgLoss += Math.abs(change);
      }
    }

    avgGain /= period;
    avgLoss /= period;

    // Apply Wilder's smoothing for remaining periods
    for (let i = period; i < changes.length; i++) {
      const change = changes[i];
      const gain = change > 0 ? change : 0;
      const loss = change < 0 ? Math.abs(change) : 0;

      // Wilder's smoothing: ((previous avg * (period-1)) + current value) 
  / period
      avgGain = (avgGain * (period - 1) + gain) / period;
      avgLoss = (avgLoss * (period - 1) + loss) / period;
    }

    if (avgLoss === 0) return 100;

    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));

    // Ensure bounds [0, 100]
    return Math.max(0, Math.min(100, rsi));
  }

  1.3 Fix Bollinger %B Calculation

  File: /server/services/data-conversion-service.ts
  Lines: 245-271

  Current Issue (line 257):
  const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma, 2),
   0) / period;

  Fixed Implementation:
  private calculateBollingerBands(closes: number[], period: number = 20,
  multiplier: number = 2): {
    upper: number | null;
    middle: number | null;
    lower: number | null;
    percent_b: number | null;
  } {
    if (closes.length < period) {
      return { upper: null, middle: null, lower: null, percent_b: null };
    }

    const slice = closes.slice(-period);
    const sma = slice.reduce((sum, val) => sum + val, 0) / period;

    // FIX: Use sample variance (N-1) instead of population variance (N)
    const variance = slice.reduce((sum, val) => sum + Math.pow(val - sma,
  2), 0) / (period - 1);
    const stdDev = Math.sqrt(variance);

    const upper = sma + (multiplier * stdDev);
    const lower = sma - (multiplier * stdDev);
    const currentPrice = closes[closes.length - 1];

    // Ensure valid %B calculation
    const bandWidth = upper - lower;
    const percent_b = bandWidth > 0 ? (currentPrice - lower) / bandWidth :
  0.5;

    return {
      upper,
      middle: sma,
      lower,
      percent_b: Math.max(0, Math.min(1, percent_b)) // Clamp to [0, 1] 
  range
    };
  }

  Phase 2: Z-Score Standardization (Priority 2)

  2.1 Create Standard Technical Indicators Service

  New File: /server/services/standard-technical-indicators.ts

  /**
   * Standard Technical Indicators Service
   * Implements industry-standard calculations for MACD(12,26,9), RSI(14), 
  Bollinger(20,2)
   */

  export interface StandardTechnicalIndicators {
    symbol: string;
    timestamp: Date;

    // Raw indicator values (not Z-scores)
    rsi: number | null;           // 14-period RSI
    macd: number | null;          // MACD line (EMA12 - EMA26)
    macdSignal: number | null;    // 9-period EMA of MACD
    macdHistogram: number | null; // MACD - Signal

    // Bollinger Bands (20, 2)
    bollingerUpper: number | null;
    bollingerMiddle: number | null;  // 20-period SMA
    bollingerLower: number | null;
    bollingerPercentB: number | null; // %B position

    // Z-scores (for advanced analysis only)
    rsiZScore: number | null;
    macdZScore: number | null;
    bollingerZScore: number | null;
  }

  export class StandardTechnicalIndicatorsService {
    private static instance: StandardTechnicalIndicatorsService;

    public static getInstance(): StandardTechnicalIndicatorsService {
      if (!this.instance) {
        this.instance = new StandardTechnicalIndicatorsService();
      }
      return this.instance;
    }

    /**
     * Calculate standard technical indicators for display
     */
    async calculateStandardIndicators(symbol: string):
  Promise<StandardTechnicalIndicators | null> {
      try {
        // Get 100 days of price data for reliable calculations
        const priceData = await this.getPriceHistory(symbol, 100);
        if (priceData.length < 50) return null;

        const closes = priceData.map(d => parseFloat(d.close));
        const highs = priceData.map(d => parseFloat(d.high));
        const lows = priceData.map(d => parseFloat(d.low));

        // Calculate standard indicators
        const rsi = this.calculateStandardRSI(closes, 14);
        const { macd, signal, histogram } =
  this.calculateStandardMACD(closes);
        const bollinger = this.calculateStandardBollinger(closes, 20, 2);

        // Calculate Z-scores using 60-day rolling window (standard for 
  daily data)
        const rsiZScore = this.calculateZScore(closes.map((_, i) =>
  this.calculateStandardRSI(closes.slice(0, i + 1), 14)).filter(v => v !==
  null), rsi, 60);
        const macdValues = closes.map((_, i) => {
          const result = this.calculateStandardMACD(closes.slice(0, i +
  1));
          return result.macd;
        }).filter(v => v !== null);
        const macdZScore = this.calculateZScore(macdValues, macd, 60);
        const bollingerZScore = this.calculateZScore(closes.map((_, i) =>
  this.calculateStandardBollinger(closes.slice(0, i + 1), 20,
  2).percent_b).filter(v => v !== null), bollinger.percent_b, 60);

        return {
          symbol,
          timestamp: new Date(),

          // Raw values for dashboard display
          rsi,
          macd,
          macdSignal: signal,
          macdHistogram: histogram,

          bollingerUpper: bollinger.upper,
          bollingerMiddle: bollinger.middle,
          bollingerLower: bollinger.lower,
          bollingerPercentB: bollinger.percent_b,

          // Z-scores for advanced analysis
          rsiZScore,
          macdZScore,
          bollingerZScore
        };

      } catch (error) {
        console.error(`Error calculating standard indicators for 
  ${symbol}:`, error);
        return null;
      }
    }

    private calculateZScore(historicalValues: number[], currentValue:
  number | null, window: number): number | null {
      if (!currentValue || historicalValues.length < window) return null;

      const recentValues = historicalValues.slice(-window);
      const mean = recentValues.reduce((sum, val) => sum + val, 0) /
  recentValues.length;
      const variance = recentValues.reduce((sum, val) => sum + Math.pow(val
   - mean, 2), 0) / (recentValues.length - 1);
      const stdDev = Math.sqrt(variance);

      return stdDev > 1e-8 ? (currentValue - mean) / stdDev : 0;
    }

    // Use the corrected calculation methods from Phase 1
    private calculateStandardRSI = /* Copy fixed RSI method from Phase 1 
  */;
    private calculateStandardMACD = /* Copy fixed MACD method from Phase 1 
  */;
    private calculateStandardBollinger = /* Copy fixed Bollinger method 
  from Phase 1 */;
  }

  2.2 Update ETF Metrics Service Integration

  File: /server/services/etf-metrics-service.ts
  Lines: 196-214 (database fetching section)

  Add import:
  import { StandardTechnicalIndicatorsService } from
  './standard-technical-indicators';

  Replace technical indicators fetching (around line 198):
  // 5. OPTIMIZED: Use standard technical indicators instead of database 
  fallbacks
  const standardTechService =
  StandardTechnicalIndicatorsService.getInstance();
  const standardIndicators = await Promise.all(
    this.ETF_SYMBOLS.map(async (symbol) => {
      const indicators = await
  standardTechService.calculateStandardIndicators(symbol);
      return [symbol, indicators];
    })
  );
  const dbTechnicals = new Map(standardIndicators);

  Phase 3: Dashboard Display Fixes (Priority 2)

  3.1 Update ETF Metrics Table Component

  File: /client/src/components/ETFMetricsTable.tsx
  Lines: 54-79 (ETFMetrics interface)

  Updated Interface:
  interface ETFMetrics {
    symbol: string;
    name: string;
    price: number;
    changePercent: number;

    // CLEAR SEPARATION: Raw technical indicators for display
    technicalIndicators: {
      rsi: number | null;                    // Actual RSI value (0-100)
      macd: number | null;                   // Actual MACD line value
      macdSignal: number | null;             // MACD signal line
      macdHistogram: number | null;          // MACD histogram
      bollingerPercentB: number | null;      // Actual %B value (0-1)
      bollingerUpper: number | null;
      bollingerLower: number | null;
    };

    // SEPARATE: Z-Score analysis (advanced metrics)
    zScoreAnalysis: {
      rsiZScore: number | null;
      macdZScore: number | null;
      bollingerZScore: number | null;
      compositeZScore: number | null;
      signal: 'BUY' | 'SELL' | 'HOLD';
    } | null;

    // Other existing fields...
    maSignal: string;
    maTrend: 'bullish' | 'bearish' | 'neutral';
    maGap: number | null;
  }

  3.2 Update Table Display Logic

  File: /client/src/components/ETFMetricsTable.tsx
  Around lines 200-300 (table cells)

  Replace MACD display:
  {/* MACD Column - Show actual MACD value, not Z-score */}
  <td className="px-2 py-1 text-xs text-center">
    <div className="flex flex-col items-center gap-0.5">
      <span className={`font-medium ${
        etf.technicalIndicators?.macd && etf.technicalIndicators.macd > 0
          ? 'text-green-400'
          : 'text-red-400'
      }`}>
        {etf.technicalIndicators?.macd?.toFixed(3) || 'N/A'}
      </span>
      {etf.zScoreAnalysis?.macdZScore && (
        <span className="text-xs text-gray-400">
          Z: {etf.zScoreAnalysis.macdZScore.toFixed(2)}
        </span>
      )}
    </div>
  </td>

  Replace RSI display:
  {/* RSI Column - Show actual RSI value (0-100) */}
  <td className="px-2 py-1 text-xs text-center">
    <div className="flex flex-col items-center gap-0.5">
      <span className={`font-medium ${
        etf.technicalIndicators?.rsi 
          ? etf.technicalIndicators.rsi > 70 ? 'text-red-400'
            : etf.technicalIndicators.rsi < 30 ? 'text-green-400'
            : 'text-blue-400'
          : 'text-gray-400'
      }`}>
        {etf.technicalIndicators?.rsi?.toFixed(1) || 'N/A'}
      </span>
      {etf.zScoreAnalysis?.rsiZScore && (
        <span className="text-xs text-gray-400">
          Z: {etf.zScoreAnalysis.rsiZScore.toFixed(2)}
        </span>
      )}
    </div>
  </td>

  Replace %B display:
  {/* %B Column - Show actual %B percentage */}
  <td className="px-2 py-1 text-xs text-center">
    <div className="flex flex-col items-center gap-0.5">
      <span className={`font-medium ${
        etf.technicalIndicators?.bollingerPercentB 
          ? etf.technicalIndicators.bollingerPercentB > 0.8 ?
  'text-red-400'
            : etf.technicalIndicators.bollingerPercentB < 0.2 ?
  'text-green-400'
            : 'text-blue-400'
          : 'text-gray-400'
      }`}>
        {etf.technicalIndicators?.bollingerPercentB
          ? `${(etf.technicalIndicators.bollingerPercentB *
  100).toFixed(1)}%`
          : 'N/A'
        }
      </span>
      {etf.zScoreAnalysis?.bollingerZScore && (
        <span className="text-xs text-gray-400">
          Z: {etf.zScoreAnalysis.bollingerZScore.toFixed(2)}
        </span>
      )}
    </div>
  </td>

  Phase 4: Data Quality & Validation (Priority 3)

  4.1 Add Calculation Validation Tests

  New File: /tests/unit/services/technical-indicators.test.ts

  import { describe, it, expect } from 'vitest';
  import { StandardTechnicalIndicatorsService } from
  '../../../server/services/standard-technical-indicators';

  describe('Technical Indicators Validation', () => {
    const service = StandardTechnicalIndicatorsService.getInstance();

    // Test data: SPY prices for known RSI/MACD values
    const testPrices = [
      // Add known price sequence with verified RSI/MACD values
      440.50, 441.20, 442.10, 441.80, 440.90, // ... add more
    ];

    it('should calculate RSI correctly', () => {
      const rsi = service.calculateStandardRSI(testPrices, 14);
      expect(rsi).toBeCloseTo(60.2, 1); // Expected RSI from your 
  verification
    });

    it('should calculate MACD correctly', () => {
      const { macd } = service.calculateStandardMACD(testPrices);
      expect(macd).toBeCloseTo(5.95, 2); // Expected MACD from your 
  verification
    });

    it('should calculate Bollinger %B correctly', () => {
      const bollinger = service.calculateStandardBollinger(testPrices, 20,
  2);
      expect(bollinger.percent_b).toBeCloseTo(1.043, 3); // Expected %B 
  from your verification
    });
  });

  4.2 Add Data Freshness Monitoring

  File: /server/services/etf-metrics-service.ts
  Lines: 274-311 (getLatestPricesFromDB method)

  Update data freshness check:
  private async getLatestPricesFromDB() {
    const results = new Map();

    // IMPROVED: Reduce lookback to 2 days for fresher data
    const cutoffDate = new Date();
    cutoffDate.setDate(cutoffDate.getDate() - 2);

    for (const symbol of this.ETF_SYMBOLS) {
      try {
        const latest = await db
          .select()
          .from(stockData)
          .where(and(
            eq(stockData.symbol, symbol),
            gte(stockData.timestamp, cutoffDate)
          ))
          .orderBy(desc(stockData.timestamp))
          .limit(1);

        if (latest.length > 0) {
          const priceData = latest[0];
          const price = parseFloat(priceData.price);
          const dataAge = Date.now() - priceData.timestamp.getTime();
          const hoursOld = dataAge / (1000 * 60 * 60);

          // VALIDATION: Ensure price sanity and freshness
          if (price > 0 && isFinite(price) && hoursOld < 48) {
            results.set(symbol, { ...priceData, close: price, ts:
  priceData.timestamp });
            logger.info(`üí∞ Fresh price for ${symbol}: $${price} 
  (${hoursOld.toFixed(1)}h old)`);
          } else {
            logger.warn(`üö® Stale/invalid price data for ${symbol}: 
  $${price}, ${hoursOld.toFixed(1)}h old`);
          }
        }
      } catch (error) {
        logger.warn(`No price data for ${symbol}:`, error);
      }
    }

    return results;
  }

  Implementation Timeline

  Day 1 (4-6 hours)

  1. Phase 1.1-1.3: Fix MACD, RSI, Bollinger calculations
  2. Phase 2.1: Create StandardTechnicalIndicatorsService
  3. Test: Verify calculations match expected values

  Day 2 (3-4 hours)

  1. Phase 2.2: Integrate standard service into ETF metrics
  2. Phase 3.1-3.2: Update dashboard display logic
  3. Test: Verify dashboard shows correct values

  Day 3 (2-3 hours)

  1. Phase 4.1-4.2: Add validation tests and monitoring
  2. Deploy: Test in production environment
  3. Verify: Compare dashboard values with your verification data

  Success Criteria

  After implementation, your dashboard should show:
  - RSI: Values matching standard 14-period calculations (~60.2 for SPY)
  - MACD: Values matching standard 12,26,9 calculations (~5.95 for SPY)
  - %B: Values matching standard 20,2 calculations (~104.3% for SPY)
  - Z-scores: Displayed separately from raw indicator values
  - Data freshness: Indicators based on recent price data (< 48 hours old)

  This plan addresses all the discrepancies identified in your comparison
  table and aligns your calculations with industry standards.