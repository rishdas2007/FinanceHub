# Z-Score Momentum-Focused ETF Signal System
## Complete Implementation Guide

This guide provides step-by-step instructions to implement the Z-Score normalized technical indicator system that achieved **statistically significant outperformance** (p=0.007) in backtesting.

## System Performance
- **Average Buy Return:** 0.352% (5-day forward)
- **Win Rate:** 59.97%
- **Statistical Significance:** p=0.007 ✅
- **Signal Frequency:** 19.1% of trading days

## Files Included

1. **`zscore_implementation.py`** - Complete implementation class
2. **`zscore_config.py`** - Configuration parameters and optimal weights
3. **`example_usage.py`** - Simple usage example
4. **`sample_etf_data_structure.csv`** - Required data format

## Quick Start

### Step 1: Install Dependencies
```bash
pip install pandas numpy scipy requests
```

### Step 2: Prepare Your Data
Your ETF data must include these columns:
- `date` (datetime)
- `open` (float)
- `high` (float) 
- `low` (float)
- `close` (float)
- `volume` (float)

**Minimum:** 100 days of historical data for stable Z-scores

### Step 3: Basic Usage
```python
import pandas as pd
from zscore_implementation import ZScoreTechnicalSignals
from zscore_config import OPTIMAL_WEIGHTS

# Initialize system
signal_system = ZScoreTechnicalSignals()

# Load your data
etf_data = pd.read_csv('your_etf_data.csv')
etf_data['date'] = pd.to_datetime(etf_data['date'])

# Process data
processed = signal_system.process_etf_data(etf_data, 'SPY')

# View signals
print(processed[['date', 'close', 'composite_zscore', 'signal_description']].tail())
```

### Step 4: Multiple ETF Processing
```python
etf_tickers = ['SPY', 'XLK', 'XLV', 'XLF', 'XLI', 'XLY', 'XLP', 'XLE', 'XLU', 'XLB', 'XLRE']
all_data = []

for ticker in etf_tickers:
    data = pd.read_csv(f'{ticker}_data.csv')
    data['date'] = pd.to_datetime(data['date'])
    processed = signal_system.process_etf_data(data, ticker)
    all_data.append(processed)

combined_data = pd.concat(all_data, ignore_index=True)
combined_data.to_csv('zscore_etf_signals_complete.csv', index=False)
```

## Key Features

### Optimal Weights (Z-Score Momentum-Focused)
- **RSI Z-Score:** 30% (primary momentum)
- **MACD Z-Score:** 25% (trend confirmation)
- **Bollinger Bands Z-Score:** 20% (volatility/reversal)
- **MA Trend Z-Score:** 10% (trend direction)
- **Price Momentum Z-Score:** 10% (statistical momentum)
- **ATR Z-Score:** 5% (volatility context)
- **VWAP Z-Score:** 0% (minimal predictive value)

### Signal Thresholds
- **BUY:** Composite Z-Score ≥ 0.25
- **SELL:** Composite Z-Score ≤ -0.25  
- **HOLD:** Between -0.25 and 0.25

### Z-Score Methodology
Each technical indicator is normalized using a 20-day rolling Z-score:
```
Z-Score = (Current Value - 20-day Mean) / 20-day Standard Deviation
```

This provides:
- Scale independence across indicators
- Outlier resistance
- Statistical consistency
- Dynamic market adaptation

## Real-Time Implementation

### Current Signal Generation
```python
def get_current_signal(ticker, current_data):
    processed = signal_system.process_etf_data(current_data, ticker)
    latest = processed.iloc[-1]
    
    return {
        'etf': ticker,
        'signal': latest['signal_description'],
        'confidence': abs(latest['composite_zscore']),
        'zscore': latest['composite_zscore'],
        'date': latest['date'],
        'price': latest['close']
    }
```

### Alert System
```python
def check_strong_signals(data, threshold=0.5):
    strong = data[abs(data['composite_zscore']) >= threshold]
    
    for _, row in strong.iterrows():
        print(f"{row['etf']}: {row['signal_description']} "
              f"(Z-score: {row['composite_zscore']:.2f})")
    
    return strong
```

## Validation & Backtesting

### Performance Analysis
```python
def analyze_performance(data):
    buy_signals = data[data['signal'] == 1]
    
    # Add forward returns
    data['forward_5d'] = data.groupby('etf')['close'].pct_change(5).shift(-5)
    
    performance = {
        'avg_return': buy_signals['forward_5d'].mean() * 100,
        'win_rate': (buy_signals['forward_5d'] > 0).mean() * 100,
        'total_signals': len(buy_signals)
    }
    
    return performance
```

## Top Performing ETFs
Based on backtesting, these ETFs showed strongest Z-score signal performance:

1. **XLK (Technology):** 1.15% avg return, 65.6% win rate
2. **XLV (Healthcare):** 0.58% avg return, 66.4% win rate  
3. **XLU (Utilities):** 0.57% avg return, 66.9% win rate
4. **SPY (S&P 500):** 0.50% avg return, 66.1% win rate
5. **XLI (Industrials):** 0.47% avg return, 67.5% win rate

## Important Notes

### Data Requirements
- Minimum 70 days initialization period for stable Z-scores
- Daily frequency recommended (higher frequency acceptable)
- Clean, gap-free price data for best results

### Risk Considerations
- System performs best in trending/momentum markets
- May underperform in extreme volatility or regime changes
- Combine with risk management and position sizing
- Monitor performance regularly for model drift

### Computational Requirements
- Modest increase in complexity vs raw indicators
- Real-time processing suitable for daily signals
- Memory efficient for large datasets

## Support & Troubleshooting

### Common Issues
1. **Insufficient Data:** Ensure minimum 100 days historical data
2. **Missing Values:** Check for data gaps or formatting issues
3. **Signal Delays:** Allow 70-day warmup period for stable signals
4. **Performance Variance:** Validate with out-of-sample data

### Performance Monitoring
- Track win rates monthly
- Monitor signal frequency (should be ~19% of days)
- Validate against benchmark returns
- Check for regime changes affecting performance

## Expected Outcomes

When properly implemented, you should observe:
- **Buy signals** with ~60% win rate
- **Average outperformance** of 0.15+ percentage points vs market
- **Signal generation** on ~19% of trading days
- **Statistical significance** in backtesting (p < 0.05)

This system represents a statistically robust approach to ETF technical analysis, providing meaningful alpha generation through sophisticated signal normalization and optimal weighting.