Detailed Implementation Approach

  1. Signal Clarity Component (25% weight)

  What it measures: How definitively each indicator points in a direction
  Current issue: economic-health-calculator.ts:296-300 uses mock correlations

  Implementation:
  async calculateSignalClarity(): Promise<number> {
    const insights = await this.economicInsightClassifier.classifyAllIndicators();

    let clarityScore = 0;
    let totalIndicators = 0;

    for (const insight of insights) {
      let indicatorClarity = 0;

      // Level signal clarity
      if (Math.abs(insight.levelSignal.zScore) > 2) indicatorClarity += 40; // Very clear
      else if (Math.abs(insight.levelSignal.zScore) > 1) indicatorClarity += 25; // Clear
      else indicatorClarity += 10; // Weak signal

      // Trend signal clarity  
      if (Math.abs(insight.trendSignal.deltaZScore) > 1.5) indicatorClarity += 40;
      else if (Math.abs(insight.trendSignal.deltaZScore) > 0.8) indicatorClarity += 25;
      else indicatorClarity += 10;

      // Penalty for conflicting signals
      if (insight.signalConflict === 'MAJOR') indicatorClarity *= 0.5;
      else if (insight.signalConflict === 'MODERATE') indicatorClarity *= 0.7;

      clarityScore += indicatorClarity;
      totalIndicators++;
    }

    return totalIndicators > 0 ? clarityScore / totalIndicators : 50;
  }

  2. Cross-Indicator Harmony (35% weight)

  What it measures: How well level and trend signals align across the economy
  Current issue: Uses hardcoded correlation expectations

  Implementation:
  async calculateCrossIndicatorHarmony(): Promise<number> {
    const insights = await this.economicInsightClassifier.classifyAllIndicators();

    // Group by categories
    const categories = {
      growth: insights.filter(i => i.category === 'Growth'),
      employment: insights.filter(i => i.category === 'Labor'),
      inflation: insights.filter(i => i.category === 'Inflation'),
      monetary: insights.filter(i => i.category === 'Monetary Policy')
    };

    let harmonyScore = 0;
    let categoryCount = 0;

    for (const [catName, indicators] of Object.entries(categories)) {
      if (indicators.length === 0) continue;

      // Within-category harmony
      const levelConsistency = this.calculateDirectionalConsistency(
        indicators.map(i => i.levelSignal.direction)
      );
      const trendConsistency = this.calculateDirectionalConsistency(
        indicators.map(i => i.trendSignal.direction)
      );

      // Level-trend alignment within category
      const levelTrendAlignment = indicators.reduce((sum, indicator) => {
        return sum + (indicator.levelSignal.direction === indicator.trendSignal.direction ? 1 : 0);
      }, 0) / indicators.length;

      const categoryHarmony = (levelConsistency * 0.4 + trendConsistency * 0.4 + levelTrendAlignment * 0.2) * 100;
      harmonyScore += categoryHarmony;
      categoryCount++;
    }

    // Cross-category harmony bonus
    const crossCategoryBonus = this.calculateCrossCategoryAlignment(categories);

    return categoryCount > 0 ? (harmonyScore / categoryCount) + crossCategoryBonus : 50;
  }

  3. Conflict Resolution (20% weight)

  What it measures: How well the system handles mixed economic signals
  Current issue: economic-health-calculator.ts:363 uses random alert frequency

  Implementation:
  async calculateConflictResolution(): Promise<number> {
    const insights = await this.economicInsightClassifier.classifyAllIndicators();

    const conflicts = insights.filter(i => i.signalConflict !== 'NONE');
    const totalConflicts = conflicts.length;
    const totalIndicators = insights.length;

    let resolutionScore = 100;

    // Penalty for high conflict rate
    const conflictRate = totalConflicts / totalIndicators;
    if (conflictRate > 0.4) resolutionScore -= 40; // >40% conflicts = major concern
    else if (conflictRate > 0.25) resolutionScore -= 25;
    else if (conflictRate > 0.15) resolutionScore -= 15;

    // Analyze conflict types
    const majorConflicts = conflicts.filter(c => c.signalConflict === 'MAJOR').length;
    const moderateConflicts = conflicts.filter(c => c.signalConflict === 'MODERATE').length;

    resolutionScore -= (majorConflicts * 8) + (moderateConflicts * 4);

    // Bonus for successful conflict contextualizations
    const contextualizedConflicts = conflicts.filter(c =>
      c.economicContext && c.economicContext.explanation
    ).length;

    if (contextualizedConflicts === totalConflicts && totalConflicts > 0) {
      resolutionScore += 10; // All conflicts have economic explanations
    }

    return Math.max(20, Math.min(100, resolutionScore));
  }

  4. Forward-Looking Accuracy (20% weight)

  What it measures: How well the framework predicts economic transitions
  Current issue: No forward-looking component exists

  Implementation:
  async calculateForwardLookingAccuracy(): Promise<number> {
    const insights = await this.economicInsightClassifier.classifyAllIndicators();

    // Analyze leading indicators specifically
    const leadingIndicators = insights.filter(i =>
      i.metric.includes('Treasury Yield') ||
      i.metric.includes('Weekly Hours') ||
      i.metric.includes('Housing Starts') ||
      i.metric.includes('Jobless Claims')
    );

    let predictiveScore = 50;

    // Strong trend signals in leading indicators = better prediction
    const strongTrendSignals = leadingIndicators.filter(i =>
      Math.abs(i.trendSignal.deltaZScore) > 1.2
    ).length;

    predictiveScore += (strongTrendSignals / leadingIndicators.length) * 30;

    // Consistent directional signals across leading indicators
    const directions = leadingIndicators.map(i => i.trendSignal.direction);
    const consistency = this.calculateDirectionalConsistency(directions);
    predictiveScore += consistency * 20;

    // Factor in regime transition probability
    const transitionRisk = await this.calculateRegimeTransitionRisk(insights);
    if (transitionRisk < 0.2) predictiveScore += 15; // Low transition risk = more predictable
    else if (transitionRisk > 0.6) predictiveScore -= 15; // High transition risk = less predictable

    return Math.max(20, Math.min(100, predictiveScore));
  }

  5. Integration into Main Health Score

  Updated Weight Structure:
  private readonly ENHANCED_SCORE_WEIGHTS = {
    // Core Economic Strength (30 points) - reduced from 40
    gdpHealth: 12,
    employmentHealth: 12,
    inflationStability: 6,

    // Multi-Dimensional Signal Analysis (35 points) - NEW
    signalClarity: 9,        // 25% of 35
    crossIndicatorHarmony: 12, // 35% of 35  
    conflictResolution: 7,     // 20% of 35
    forwardLookingAccuracy: 7, // 20% of 35

    // Market Stress & Volatility (20 points)
    alertFrequency: 10,
    regimeStability: 10,

    // Data Quality & Confidence (15 points)
    dataQuality: 8,
    sectorAlignment: 7
  };

  This transforms the health score from a simple weighted average into a sophisticated economic intelligence system that captures the nuanced, multi-dimensional nature of economic conditions.