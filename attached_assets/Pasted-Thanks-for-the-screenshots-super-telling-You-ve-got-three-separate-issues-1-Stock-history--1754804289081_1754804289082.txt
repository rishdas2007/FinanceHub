Thanks for the screenshots—super telling. You’ve got **three separate issues**:

1. **Stock history modals (SPY/XLK) render blank** → the history endpoint is returning **zero rows** after the TIMESTAMPTZ changes.
2. **ETF Technical Metrics look “fabricated”** → the service is falling back to a **stub/legacy path** that emits constant or placeholder values.
3. **Economic chart modal 404 (e.g., 10-Year)** → the client still calls an **old route**; the server only exposes the new Silver/Gold routes.

Here’s a tight, targeted fix set that will unbrick all three.

---

# 1) Stock history: return real rows (DB→provider, daily, UTC)

**Symptom:** Blank chart; CSV returns empty; logs show no error.
**Cause:** Your DB query now compares `TIMESTAMPTZ` to strings (or the window bounds are off by one). If DB returns 0, you don’t hit the provider fallback.

### Hotfix (server)

```ts
// controllers/price-history.ts
app.get('/api/stocks/:symbol/history', async (req, res) => {
  const symbol = String(req.params.symbol || '').toUpperCase();
  const window = String(req.query.window || '90D').toUpperCase();

  const days = window === '7D' ? 7 : window === '30D' ? 30 : 90;

  // UTC day bounds (end-exclusive)
  const todayUTC = new Date(Date.UTC(
    new Date().getUTCFullYear(),
    new Date().getUTCMonth(),
    new Date().getUTCDate()
  ));
  const startTs = new Date(todayUTC); startTs.setUTCDate(startTs.getUTCDate() - days);
  const endTs   = new Date(todayUTC); endTs.setUTCDate(endTs.getUTCDate() + 1);

  try {
    // 1) DB first
    const rows = await db.query(sql`
      SELECT date, close
      FROM historical_stock_data
      WHERE symbol = ${symbol}
        AND date >= ${startTs}::timestamptz
        AND date <  ${endTs}::timestamptz
      ORDER BY date ASC
    `);

    let series = rows.map(r => ({
      t: new Date(r.date).getTime(),
      date: new Date(r.date).toISOString().slice(0,10),
      close: Number(r.close),
      source: 'db' as const,
    }));

    // 2) Provider fallback if DB empty
    if (series.length === 0) {
      const raw = await twelveData.timeSeries({
        symbol,
        interval: '1day',
        start_date: startTs.toISOString().slice(0,10),
        end_date:   endTs.toISOString().slice(0,10),
        outputsize: 1000,
        // exchange: 'ARCA', // uncomment for ETFs if needed by your provider
      });
      const vals = raw?.values ?? raw?.data ?? [];
      series = vals
        .map((v: any) => ({
          date: String(v.datetime ?? v.date ?? v.time).slice(0,10),
          t: Date.parse(String(v.datetime ?? v.date ?? v.time)),
          close: Number(v.close ?? v.c ?? v.adj_close),
          source: 'provider' as const,
        }))
        .filter(d => Number.isFinite(d.close) && d.t)
        .sort((a,b) => a.t - b.t);
    }

    return res.json({ success: true, data: series });
  } catch (e:any) {
    console.error('HISTORY ERROR', symbol, e?.message);
    return res.json({ success: true, data: [], warning: 'data_unavailable' });
  }
});
```

**Client (Recharts X-axis stays happy):**

```tsx
<XAxis type="number" dataKey="t" domain={['dataMin','dataMax']}
       tickFormatter={(ms) => new Date(ms).toLocaleDateString()} />
<Line dataKey="close" />
```

**Why this fixes it:** real **daily** bars in UTC; DB first; provider fallback; end-exclusive avoids off-by-one; chart uses numeric ticks.

---

# 2) ETF Technical Metrics: stop stubs, compute only with real data

**Symptom:** uniform/odd values (e.g., same Z across ETFs, “Legacy Analysis” tags).
**Cause:** service hit **fallback/sample/legacy** path when features or history missing.

### Hotfix (service + controller)

* **Delete/disable** any `generateSample*` or “legacy metrics” branches.
* Require a **minimum lookback** (e.g., 252 trading days) before computing z-scores/RSI/etc.
* When insufficient data → **return nulls**, not fake numbers, and set a `fallback: true` flag.

```ts
// services/etf-metrics-service.ts
const MIN_OBS = 180; // or 252

export async function getAllMetrics(symbols: string[]) {
  const out: any[] = [];
  for (const s of symbols) {
    const hist = await loadDailyCloses(s, /* last N */ 400);
    if (!hist || hist.length < MIN_OBS) {
      out.push({ symbol: s, fallback: true, reason: 'insufficient_history' });
      continue;
    }
    const closes = hist.map(h => h.close);
    const rsi = computeRSI(closes, 14);
    const z = zScore(closes.slice(-252)); // level vs 252d mean/sd
    // … your other metrics …
    out.push({ symbol: s, fallback: false, rsi, zScore: z, /* … */ });
  }
  return out;
}
```

**Controller must never emit `null`**:

```ts
const metrics = await getAllMetrics(universe);
return res.json({ success: true, data: metrics });
```

**Client:** if `row.fallback` → badge “No Data / Using Live Only” and **hide** composite signals for that row (don’t fabricate).

---

# 3) Economic charts 404: route alias + fail-soft

**Symptom:** “Failed to fetch chart data: 404 (Metric ID: 10\_year\_treasury\_yield | Range: 12M)”.
**Cause:** client is calling an old path (e.g., `/api/econ/metrics/:id/chart`) but you only implemented `/api/econ/observations`.

### Hotfix (server)

Add a **compatibility alias** that maps `metricId` → your `econ_series_def.series_id` and returns Silver observations:

```ts
// controllers/econ-compat.ts
app.get('/api/econ/metrics/:id/chart', async (req, res) => {
  const id = String(req.params.id);
  const range = String(req.query.range || '12M').toUpperCase(); // '3M'|'6M'|'12M'|'5Y'
  const months = range === '3M' ? 3 : range === '6M' ? 6 : range === '5Y' ? 60 : 12;

  try {
    const def = await db.query(sql`SELECT series_id FROM econ_series_def WHERE series_id = ${id} OR legacy_id = ${id} LIMIT 1`);
    if (!def?.length) return res.json({ success: true, data: [] }); // no 404

    const end = new Date(); const start = new Date(); start.setUTCMonth(start.getUTCMonth()-months);
    const rows = await db.query(sql`
      SELECT period_end, value_std
      FROM econ_series_observation
      WHERE series_id = ${def[0].series_id}
        AND period_end >= ${start.toISOString().slice(0,10)}::date
      ORDER BY period_end ASC
    `);

    const data = rows.map(r => ({
      t: Date.parse(r.period_end),
      date: String(r.period_end),
      value: Number(r.value_std),
    }));
    return res.json({ success: true, data });
  } catch (e:any) {
    console.error('ECON CHART ERROR', id, e?.message);
    return res.json({ success: true, data: [], warning: 'data_unavailable' });
  }
});
```

**Client:** keep using your existing modal—now it gets `{success:true,data:[...]}` instead of 404.

---

# Quick verification checklist (2 minutes)

* **/api/stocks/SPY/history?window=30D** → `{success:true,data:[{t, date, close, source}]}` with \~30 points.
* **/api/etf-metrics** → `{success:true,data:[…]}` no `null`; any row with `fallback:true` is visibly badged in UI.
* **/api/econ/metrics/10\_year\_treasury\_yield/chart?range=12M** → `{success:true,data:[…]}` (not 404).
* Recharts X-axis shows dates; 7D/30D/90D have different point counts.
* No console errors about `toISOString`.

---

If you want, I can prep a small PR with:

* the **history** endpoint DB→provider fallback and numeric ticks,
* the **ETF metrics** “no stubs” pipeline + fallback flag,
* the **econ chart** compatibility route,
* and the tiny **UI badges/empty-state** tweaks so the app never presents fabricated values again.

Shoot me which provider you’re using for daily bars (TwelveData/FMP/etc.) so I can set the right fields (`datetime` vs `date`, `close` vs `c`) in the normalizer.
