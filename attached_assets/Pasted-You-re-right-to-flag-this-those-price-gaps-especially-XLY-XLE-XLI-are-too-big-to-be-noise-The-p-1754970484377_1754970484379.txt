You're right to flag this—those price gaps (especially XLY/XLE/XLI) are too big to be “noise.” The pattern screams **data-path desync**: you’re mixing a stale DB snapshot for prices with fresh indicator math (or vice‑versa), plus a couple of schema/version quirks.

Here’s a tight, actionable plan to get the table trustworthy again and keep it that way.

# What likely went wrong (from your logs + table)

* **Two sources, one table:** Logs say “database‑first pipeline” *and* “fetched fresh momentum data… from API.” That can easily yield **fresh indicators on stale prices**.
* **Stale materialized table:** `etf_metrics_latest` probably wasn’t refreshed at market close (or the cache served an old row). XLY at \~\$195 looks like an older level.
* **Indicator spec drift:** The SPY MACD mismatch suggests either non‑standard params, unadjusted prices, or a different timeframe than the table label implies.
* **304 handling:** You’re seeing 304s on `/econ/sparkline`. If the ETag key isn’t invalidated when the underlying DB updates, the client may keep old series.

# Fast fixes (today)

1. **Single source of truth per payload**

   * In the bulk endpoint, **derive everything from the same OHLC snapshot** (one `asOf` timestamp).
   * If indicators are precomputed elsewhere, **do not merge** with prices from a different timestamp.

2. **Hard fail on inconsistent timestamps**

   * After you build the 12‑ETF payload:

     * ensure `max(asOf) - min(asOf) ≤ 60s`,
     * ensure *all* originate from the same `provider_version`.
   * If not, **return 503 + “stale/mixed data”** and keep serving the last good cache.

3. **Use adjusted close for indicators**

   * Standard MACD params: **12/26/9** on adjusted close. Lock this in and document it.
   * If you must use close (not adjusted), label it and expect small deviations vs. websites.

4. **Invalidate caches properly**

   * When the ETL refreshes `etf_metrics_latest`, **bump a content hash** and use that for the ETag.
   * Don’t reuse the old ETag on the same URL after a DB refresh.

5. **Guardrails on price sanity**

   * Outside market hours, if `|display_price – reference_close| / reference_close > 2%`, flag the row as **stale** (yellow badge) and surface a banner: “Using cached data as of YYYY‑MM‑DD HH\:MM ET.”

# Concrete code (drop‑in)

**A) Server: validate one‑snapshot payload (TypeScript)**

```ts
// server/services/validatePayload.ts
export function validateEtfPayload(items: Array<{symbol:string; last_price:number; asOf:string; provider:string}>) {
  if (!items?.length) throw new Error('No items');
  const times = items.map(i => new Date(i.asOf).getTime());
  const tmin = Math.min(...times), tmax = Math.max(...times);
  if (tmax - tmin > 60_000) throw new Error('Mixed timestamps in payload');

  const providers = new Set(items.map(i => i.provider));
  if (providers.size > 1) throw new Error('Mixed providers in payload');

  for (const i of items) {
    if (!isFinite(i.last_price) || i.last_price <= 0) throw new Error(`Bad price for ${i.symbol}`);
  }
  return { asOf: new Date(tmax).toISOString(), provider: items[0].provider };
}
```

Use it in the bulk endpoint **before** you compute the ETag:

```ts
const data = await getEtfMetricsLatest(); // rows include asOf + provider
const meta = validateEtfPayload(data);
const payload = JSON.stringify({ version: 1, updatedAt: meta.asOf, provider: meta.provider, items: data });
```

**B) Server: refresh + strong ETag tied to content**

```ts
import crypto from 'crypto';
const etag = 'W/"' + crypto.createHash('sha1').update(payload).digest('hex') + '"'; // weak etag ok
res.setHeader('ETag', etag);
```

**C) Server: MACD spec + adjusted close**
Make sure your indicator builder uses:

```ts
const MACD_FAST = 12, MACD_SLOW = 26, MACD_SIGNAL = 9;
// input: adjustedClose[]
```

…and store that spec in the row (e.g., `indicator_spec: "MACD(12,26,9)|ADJ"`).

**D) Client: show provenance and guard stale**
Add a small line above the table:

```
“As of 2025‑08‑11 16:05 ET · Source: Twelve Data (adj close) · version 1”
```

If the server returns `stale: true` or the sanity check badge, show a yellow banner and avoid rendering signals that rely on stale fields.

# Investigation checklist (to run now)

* Query your DB:

  ```sql
  SELECT symbol, last_price, as_of, provider, updated_at
  FROM etf_metrics_latest
  ORDER BY symbol;
  ```

  Confirm XLY/XLI/XLE rows are out of date vs. others.
* Check scheduler logs at 16:05–16:30 ET: did the refresh succeed and warm the cache?
* Verify the **client is not merging** price from v1 and indicators from v2 or vice versa.
* Confirm MACD code path uses the same series the price comes from (adj close vs close; daily timeframe).

# Prevent it forever (DQ layer)

1. **Canary cross‑check**: for 3 tickers (SPY, XLY, XLE), fetch a second provider on the scheduler (or once nightly) and store `ref_close`. If `|price‑ref|>2%` → set `dq_status = 'mismatch'` and refuse to publish new payloads until resolved.
2. **Unit tests**: lock expected MACD/RSI for a known historical window (e.g., SPY 2025‑08‑11) with tolerances.
3. **Payload contract**: require `version`, `asOf`, `provider`, `indicator_spec`, and `dq_status` in the API. The client refuses to compute signals when `dq_status!='ok'`.

---

If you want, I can generate:

* a SQL patch to add `as_of`, `provider`, `indicator_spec`, `dq_status` columns to `etf_metrics_latest`,
* a server patch to run `validateEtfPayload`, compute ETag from content, and set a `stale` flag,
* a client patch to display provenance/stale banners and *not* crash on 304.

Say the word and I’ll package those as a single markdown PR you can drop in.
