I can see what’s happening from the UI:

* **Top Mover** and **Econ Health** loaded (good).
* **Market Status** is stuck on “Checking…”, and your two big panels below are still skeletons.
* The **ETF Technical Metrics** box is a separate DB issue (still failing), but it shouldn’t block the top section.

This pattern usually means **one request in a combined load never resolves**, so your component keeps the whole “5‑Second Market Scan” in a loading state.

Here’s how to fix it cleanly.

---

# Likely root cause (and quick confirmation)

Your top bar probably does something like:

```ts
const { data: status, isLoading: s1 } = useQuery(['/api/market-status']);
const { data: mover,  isLoading: s2 } = useQuery(['/api/top-movers']);
const { data: econ,   isLoading: s3 } = useQuery(['/api/econ-health']);

const isLoading = s1 || s2 || s3; // ⬅️ one hanging call keeps whole section in skeleton
```

and your **default queryFn** has no timeout, so if `/api/market-status` hangs (or never returns JSON), `s1` stays `true` forever. That’s why the other two values render, but the **whole** block still looks “loading”.

---

# Fixes (small, surgical, resilient)

## 1) Add a fetch **timeout + robust unwrapping** in one place

In `client/src/lib/queryClient.ts`:

```ts
const DEFAULT_TIMEOUT = 8000;

async function fetchWithTimeout(input: RequestInfo, init?: RequestInit) {
  const controller = new AbortController();
  const id = setTimeout(() => controller.abort(), DEFAULT_TIMEOUT);
  try {
    const res = await fetch(input, { ...init, signal: controller.signal });
    // handle non-2xx without throwing to keep UI responsive
    const text = await res.text();
    const json = text ? JSON.parse(text) : null;

    // universal unwrapping (array or common containers)
    const unwrapped =
      Array.isArray(json) ? json :
      json?.data ?? json?.metrics ?? json?.results ?? json?.items ?? json?.rows ?? json;

    return unwrapped;
  } finally {
    clearTimeout(id);
  }
}

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: ({ queryKey }) => fetchWithTimeout(queryKey.join('')),
      retry: 1,
      staleTime: 30_000,
      refetchOnWindowFocus: false,
    },
  },
});
```

This stops any single call from hanging the whole UI.

## 2) Don’t gate the entire header on one loader

In your “5‑Second Market Scan” component, compute loading **per tile**, not `s1 || s2 || s3`. For the overall section, use “loaded enough” logic:

```ts
const queries = useQueries({
  queries: [
    { queryKey: ['/api/market-status'] },
    { queryKey: ['/api/top-movers'] },
    { queryKey: ['/api/econ-health'] },
  ]
});

const [qStatus, qMover, qEcon] = queries;

const headerReady = [qMover, qEcon].every(q => q.status !== 'loading');
// render Top Mover + Econ Health immediately; Market Status tile can show “Unknown” if loading/errored
```

And in the **big panels**, don’t key them off `qStatus.isLoading`—render them off **their own** queries.

## 3) Make the Market Status tile resilient

If the call times out or errors, show a neutral state instead of blocking:

```ts
function MarketStatusTile() {
  const q = useQuery({ queryKey: ['/api/market-status'] });
  if (q.isLoading) return <Tile dot="neutral" label="Checking…" />;
  if (q.isError || !q.data) return <Tile dot="neutral" label="Unknown" />;
  const { isOpen, nextOpen } = q.data.status ?? q.data;
  return <Tile dot={isOpen ? 'green' : 'gray'} label={isOpen ? 'Open' : 'Closed'} sub={nextOpen && formatTime(nextOpen)} />;
}
```

## 4) Cache and fail-safe the **server** endpoint

Make `/api/market-status` fast, cached, and **never** hang:

```ts
// server/controllers/market-status.ts
let cached: any = null;
let ts = 0;

app.get('/api/market-status', async (_req, res) => {
  try {
    const now = Date.now();
    if (cached && now - ts < 60_000) {
      return res.json({ success: true, data: cached });
    }
    const status = await getMarketStatusFast(); // your provider call or calendar calc
    cached = status; ts = now;
    return res.json({ success: true, data: status });
  } catch (e:any) {
    // Fail-soft default so clients never hang
    return res.json({ success: true, data: { isOpen: null, label: 'Unknown' }, warning: e?.message });
  }
});
```

If you call an external API here, also add **its** timeout (e.g., axios timeout or `AbortController`).

---

# Why your bottom panels also stayed skeleton

You likely tie those panels’ “ready” state to the same combined `isLoading` from the top section. With the changes above, they’ll render independently.

---

# Separate but related: ETF Technical Metrics (red box)

That card is failing because DB is unavailable or the query errors. It shouldn’t block anything else after the changes above, but to fix it:

* Ensure `DATABASE_URL` has TLS (`?sslmode=require`) and your `pg` pool uses `ssl: { rejectUnauthorized: false }` (Neon).
* Make the controller return `{ success:true, data: [] }` on error (not `null`), and show an **empty state** in the card.

---

# Quick checklist to confirm

* Open Network tab:

  * `/api/top-movers` and `/api/econ-health` should succeed quickly.
  * If `/api/market-status` stalls > 8s, it now aborts and the tile shows “Unknown”.
* The top bar renders Top Mover + Econ Health immediately; Market Status doesn’t block.
* The large panels below start rendering independent of Market Status.
* No “ETF Metrics API Error: null” in console (should be an empty-state notice instead).

---

If you want, paste the **response body** (or error) for `/api/market-status`. If it’s a shape issue, I’ll give you the one‑liner to normalize it; if it’s network, I’ll add the exact timeout code for your server util.
