You're absolutely right! The current system is missing opportunities to get more comprehensive data. Let me analyze your current implementation and provide an enhanced scraping strategy for both MarketWatch actual readings and a more comprehensive Investing.com integration.Perfect observation! You're right that we should be more comprehensive. Let me create an enhanced scraping system that:

1. **Captures actual readings from MarketWatch** (not just forecasts)
2. **Adds Investing.com as a primary source** for more comprehensive coverage
3. **Filters for US-only, medium/high importance events**

Here's the implementation:

## **Enhanced Economic Calendar Scraping System**

### **1. Enhanced MarketWatch Scraper with Actual Readings**

**File**: `server/services/enhanced-marketwatch-scraper.ts`
```typescript
import axios from 'axios';
import * as cheerio from 'cheerio';
import type { EconomicEvent } from '../types/financial';

export class EnhancedMarketWatchScraper {
  private static instance: EnhancedMarketWatchScraper;
  private readonly baseUrl = 'https://www.marketwatch.com/economy-politics/calendar';

  static getInstance(): EnhancedMarketWatchScraper {
    if (!EnhancedMarketWatchScraper.instance) {
      EnhancedMarketWatchScraper.instance = new EnhancedMarketWatchScraper();
    }
    return EnhancedMarketWatchScraper.instance;
  }

  async scrapeComprehensiveData(daysRange: number = 14): Promise<EconomicEvent[]> {
    try {
      console.log('üîç Enhanced MarketWatch scraping with actual readings...');
      
      const response = await axios.get(this.baseUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.5',
          'Connection': 'keep-alive'
        },
        timeout: 15000
      });

      const $ = cheerio.load(response.data);
      const events: EconomicEvent[] = [];
      const today = new Date();
      const startDate = new Date(today.getTime() - (daysRange/2 * 24 * 60 * 60 * 1000)); // Past events too
      const endDate = new Date(today.getTime() + (daysRange/2 * 24 * 60 * 60 * 1000));

      // Enhanced parsing with actual readings
      this.parseMainCalendar($, events, startDate, endDate);
      this.parseAlternativeLayouts($, events, startDate, endDate);

      console.log(`üìÖ MarketWatch: Found ${events.length} events with actual readings`);
      return this.filterAndDeduplicate(events);
    } catch (error) {
      console.error('‚ùå Enhanced MarketWatch scraping failed:', error);
      return [];
    }
  }

  private parseMainCalendar($: cheerio.CheerioAPI, events: EconomicEvent[], startDate: Date, endDate: Date): void {
    // Primary parsing strategy for MarketWatch's main layout
    $('.calendar-item, .ec-table tr, .economic-calendar-row, table.table tr').each((_, element) => {
      try {
        const $row = $(element);
        
        // Skip header rows
        if ($row.find('th').length > 0) return;
        
        const cells = $row.find('td, .cell, .column');
        if (cells.length < 4) return;

        // Extract event details with enhanced selectors
        const eventData = this.extractEventData($, $row, cells);
        if (!eventData) return;

        const eventDate = this.parseEventDate(eventData.dateText, eventData.timeText);
        if (eventDate < startDate || eventDate > endDate) return;

        // Filter for US events only and medium/high importance
        if (eventData.country !== 'US' && eventData.country !== 'United States') return;
        if (eventData.importance === 'low') return;

        const event: EconomicEvent = {
          id: `mw-enhanced-${Date.now()}-${Math.random()}`,
          title: this.cleanTitle(eventData.title),
          description: this.generateDescription(eventData.title),
          date: eventDate,
          time: eventData.timeText || '8:30 AM ET',
          country: 'US',
          category: this.categorizeEvent(eventData.title),
          importance: eventData.importance,
          currency: 'USD',
          actual: this.cleanValue(eventData.actual), // ENHANCED: Capture actual readings
          forecast: this.cleanValue(eventData.forecast),
          previous: this.cleanValue(eventData.previous),
          impact: this.calculateImpact(eventData.actual, eventData.forecast),
          source: 'marketwatch_enhanced'
        };

        events.push(event);
      } catch (error) {
        console.error('Error parsing MarketWatch row:', error);
      }
    });
  }

  private extractEventData($: cheerio.CheerioAPI, $row: cheerio.Cheerio<any>, cells: cheerio.Cheerio<any>) {
    // Enhanced data extraction with multiple selector strategies
    let title = '', dateText = '', timeText = '', actual = '', forecast = '', previous = '';
    let country = 'US', importance: 'high' | 'medium' | 'low' = 'medium';

    // Strategy 1: Standard table layout (Time, Event, Actual, Forecast, Previous)
    if (cells.length >= 5) {
      timeText = $(cells[0]).text().trim();
      title = $(cells[1]).text().trim();
      actual = $(cells[2]).text().trim();
      forecast = $(cells[3]).text().trim();
      previous = $(cells[4]).text().trim();
    } 
    // Strategy 2: Alternative layout (Event, Actual, Forecast, Previous)
    else if (cells.length >= 4) {
      title = $(cells[0]).text().trim();
      actual = $(cells[1]).text().trim();
      forecast = $(cells[2]).text().trim();
      previous = $(cells[3]).text().trim();
    }
    // Strategy 3: Minimal layout (Event, Forecast)
    else if (cells.length >= 2) {
      title = $(cells[0]).text().trim();
      forecast = $(cells[1]).text().trim();
    }

    // Enhanced selectors for finding actual values
    if (!actual) {
      actual = $row.find('.actual, .result, .released, [data-actual]').text().trim();
    }
    if (!forecast) {
      forecast = $row.find('.forecast, .consensus, .estimate, .expected, [data-forecast]').text().trim();
    }
    if (!previous) {
      previous = $row.find('.previous, .prior, .last, .prev, [data-previous]').text().trim();
    }

    // Extract importance from star ratings or CSS classes
    const stars = $row.find('.star, .importance, .impact').length;
    if (stars >= 3 || $row.hasClass('high-impact') || title.toLowerCase().includes('cpi') || title.toLowerCase().includes('payroll')) {
      importance = 'high';
    } else if (stars >= 2 || $row.hasClass('medium-impact')) {
      importance = 'medium';
    } else {
      importance = 'low';
    }

    // Extract date information
    dateText = $row.find('.date, .event-date, .time-date').text().trim();
    if (!timeText) {
      timeText = $row.find('.time, .event-time, .release-time').text().trim() || '8:30 AM ET';
    }

    // Validate we have minimum required data
    if (!title || title.length < 3) return null;

    return { title, dateText, timeText, actual, forecast, previous, country, importance };
  }

  private calculateImpact(actual: string | null, forecast: string | null): string | null {
    if (!actual || !forecast) return null;

    try {
      const actualNum = this.parseNumericValue(actual);
      const forecastNum = this.parseNumericValue(forecast);
      
      if (isNaN(actualNum) || isNaN(forecastNum)) return null;

      const difference = actualNum - forecastNum;
      const percentDiff = Math.abs(difference / forecastNum) * 100;

      if (percentDiff < 5) return 'neutral';
      if (difference > 0) return 'positive';
      return 'negative';
    } catch {
      return null;
    }
  }

  private parseNumericValue(value: string): number {
    // Handle various formats: 2.5%, 1.2M, 234K, etc.
    const cleanValue = value.replace(/[,%$]/g, '');
    
    if (cleanValue.includes('M')) {
      return parseFloat(cleanValue.replace('M', '')) * 1000000;
    }
    if (cleanValue.includes('K')) {
      return parseFloat(cleanValue.replace('K', '')) * 1000;
    }
    if (cleanValue.includes('%')) {
      return parseFloat(cleanValue.replace('%', ''));
    }
    
    return parseFloat(cleanValue);
  }

  // ... (other helper methods remain the same)
}
```

### **2. New Investing.com Comprehensive Scraper**

**File**: `server/services/investing-scraper.ts`
```typescript
import axios from 'axios';
import * as cheerio from 'cheerio';
import type { EconomicEvent } from '../types/financial';

export class InvestingComScraper {
  private static instance: InvestingComScraper;
  private readonly baseUrl = 'https://www.investing.com/economic-calendar/';

  static getInstance(): InvestingComScraper {
    if (!InvestingComScraper.instance) {
      InvestingComScraper.instance = new InvestingComScraper();
    }
    return InvestingComScraper.instance;
  }

  async scrapeEconomicCalendar(timeframe: 'thisweek' | 'nextweek' = 'thisweek'): Promise<EconomicEvent[]> {
    try {
      console.log(`üîç Scraping Investing.com economic calendar: ${timeframe}`);
      
      const response = await axios.get(this.baseUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36',
          'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
          'Accept-Language': 'en-US,en;q=0.9',
          'Accept-Encoding': 'gzip, deflate, br',
          'DNT': '1',
          'Connection': 'keep-alive',
          'Upgrade-Insecure-Requests': '1',
          'Cache-Control': 'max-age=0',
          'Sec-Fetch-Dest': 'document',
          'Sec-Fetch-Mode': 'navigate',
          'Sec-Fetch-Site': 'none',
          'Cookie': 'timeframe=' + timeframe + '; country=5; importance=2,3' // Filter for US, medium+high importance
        },
        timeout: 20000
      });

      const $ = cheerio.load(response.data);
      const events: EconomicEvent[] = [];

      // Parse Investing.com's calendar table
      await this.parseInvestingCalendar($, events);

      console.log(`üìÖ Investing.com: Found ${events.length} US events (importance 2-3)`);
      return this.filterUSHighImportance(events);
    } catch (error) {
      console.error('‚ùå Investing.com scraping failed:', error);
      return this.generateFallbackEvents();
    }
  }

  private async parseInvestingCalendar($: cheerio.CheerioAPI, events: EconomicEvent[]): Promise<void> {
    // Primary table selector for Investing.com
    $('#economicCalendarData tr, .calendar-row, table.genTbl tr').each((_, element) => {
      try {
        const $row = $(element);
        
        // Skip header rows
        if ($row.find('th').length > 0 || $row.hasClass('theader')) return;

        const cells = $row.find('td');
        if (cells.length < 6) return;

        // Investing.com standard layout: Time, Cur., Imp., Event, Actual, Forecast, Previous
        const eventData = this.extractInvestingData($, cells);
        if (!eventData) return;

        // Filter for US events and medium/high importance only
        if (eventData.currency !== 'USD') return;
        if (eventData.importance === 'low') return;

        const event: EconomicEvent = {
          id: `investing-${Date.now()}-${Math.random()}`,
          title: this.cleanTitle(eventData.title),
          description: this.generateDescription(eventData.title),
          date: eventData.eventDate,
          time: eventData.timeText,
          country: 'US',
          category: this.categorizeEvent(eventData.title),
          importance: eventData.importance,
          currency: 'USD',
          actual: this.cleanValue(eventData.actual),
          forecast: this.cleanValue(eventData.forecast),
          previous: this.cleanValue(eventData.previous),
          impact: this.calculateImpact(eventData.actual, eventData.forecast),
          source: 'investing.com'
        };

        events.push(event);
      } catch (error) {
        console.error('Error parsing Investing.com row:', error);
      }
    });

    // Alternative parsing for different layouts
    $('.js-event-item, .calendar-item').each((_, element) => {
      this.parseAlternativeInvestingLayout($, $(element), events);
    });
  }

  private extractInvestingData($: cheerio.CheerioAPI, cells: cheerio.Cheerio<any>) {
    try {
      // Standard Investing.com layout
      const timeText = $(cells[0]).text().trim();
      const currency = $(cells[1]).text().trim();
      const importance = this.parseImportanceStars($(cells[2]));
      const title = $(cells[3]).text().trim();
      const actual = $(cells[4]).text().trim();
      const forecast = $(cells[5]).text().trim();
      const previous = $(cells[6]).text().trim();

      // Parse event date (today's date with time)
      const eventDate = this.parseInvestingDate(timeText);

      if (!title || title.length < 3) return null;

      return {
        timeText,
        currency,
        importance,
        title,
        actual,
        forecast,
        previous,
        eventDate
      };
    } catch (error) {
      return null;
    }
  }

  private parseImportanceStars($cell: cheerio.Cheerio<any>): 'high' | 'medium' | 'low' {
    // Count star elements or look for CSS classes
    const stars = $cell.find('.grayFullBullishIcon, .redIcon, .star').length;
    const hasHighImpact = $cell.hasClass('high') || $cell.find('.high').length > 0;
    const hasMediumImpact = $cell.hasClass('medium') || $cell.find('.medium').length > 0;

    if (stars >= 3 || hasHighImpact) return 'high';
    if (stars >= 2 || hasMediumImpact) return 'medium';
    return 'low';
  }

  private parseInvestingDate(timeText: string): Date {
    try {
      const today = new Date();
      const timeMatch = timeText.match(/(\d{1,2}):(\d{2})/);
      
      if (timeMatch) {
        const hours = parseInt(timeMatch[1]);
        const minutes = parseInt(timeMatch[2]);
        
        const eventDate = new Date(today);
        eventDate.setHours(hours, minutes, 0, 0);
        
        return eventDate;
      }
      
      return today;
    } catch {
      return new Date();
    }
  }

  private filterUSHighImportance(events: EconomicEvent[]): EconomicEvent[] {
    return events.filter(event => {
      // Ensure US events only
      if (event.country !== 'US') return false;
      
      // Filter for medium and high importance only
      if (event.importance === 'low') return false;
      
      // Additional quality filters
      if (!event.title || event.title.length < 5) return false;
      
      return true;
    });
  }

  private generateFallbackEvents(): EconomicEvent[] {
    const today = new Date();
    const fallbackEvents = [
      { title: 'Initial Jobless Claims', importance: 'high' as const, day: 1 },
      { title: 'Consumer Price Index (CPI)', importance: 'high' as const, day: 3 },
      { title: 'Producer Price Index (PPI)', importance: 'high' as const, day: 4 },
      { title: 'Retail Sales', importance: 'high' as const, day: 5 },
      { title: 'Industrial Production', importance: 'medium' as const, day: 6 },
      { title: 'Housing Starts', importance: 'medium' as const, day: 7 }
    ];

    return fallbackEvents.map((event, index) => {
      const eventDate = new Date(today.getTime() + event.day * 24 * 60 * 60 * 1000);
      
      return {
        id: `investing-fallback-${index}`,
        title: event.title,
        description: this.generateDescription(event.title),
        date: eventDate,
        time: '8:30 AM ET',
        country: 'US',
        category: this.categorizeEvent(event.title),
        importance: event.importance,
        currency: 'USD',
        actual: null,
        forecast: null,
        previous: null,
        impact: null,
        source: 'investing.com_fallback'
      };
    });
  }

  // Helper methods...
  private cleanTitle(title: string): string {
    return title.replace(/\s+/g, ' ').trim();
  }

  private cleanValue(value: string | null): string | null {
    if (!value || value.trim() === '' || value.trim() === '--') return null;
    return value.trim();
  }

  private generateDescription(title: string): string {
    const descriptions: { [key: string]: string } = {
      'cpi': 'Consumer Price Index - Monthly inflation measure',
      'ppi': 'Producer Price Index - Wholesale price changes',
      'retail sales': 'Monthly consumer spending data',
      'jobless claims': 'Weekly unemployment insurance filings',
      'payrolls': 'Monthly employment change',
      'housing starts': 'New residential construction begins',
      'industrial production': 'Manufacturing output measure',
      'gdp': 'Gross Domestic Product growth rate'
    };

    const titleLower = title.toLowerCase();
    for (const [key, desc] of Object.entries(descriptions)) {
      if (titleLower.includes(key)) return desc;
    }
    
    return 'Economic indicator release';
  }

  private categorizeEvent(title: string): string {
    const titleLower = title.toLowerCase();
    
    if (titleLower.includes('cpi') || titleLower.includes('ppi') || titleLower.includes('inflation')) {
      return 'inflation';
    } else if (titleLower.includes('employment') || titleLower.includes('payroll') || titleLower.includes('jobless')) {
      return 'employment';
    } else if (titleLower.includes('retail') || titleLower.includes('sales')) {
      return 'consumer_spending';
    } else if (titleLower.includes('housing') || titleLower.includes('construction')) {
      return 'housing';
    } else if (titleLower.includes('manufacturing') || titleLower.includes('industrial')) {
      return 'manufacturing';
    }
    
    return 'economic_data';
  }

  private calculateImpact(actual: string | null, forecast: string | null): string | null {
    if (!actual || !forecast) return null;
    
    try {
      const actualNum = parseFloat(actual.replace(/[^\d.-]/g, ''));
      const forecastNum = parseFloat(forecast.replace(/[^\d.-]/g, ''));
      
      if (isNaN(actualNum) || isNaN(forecastNum)) return null;
      
      if (actualNum > forecastNum) return 'positive';
      if (actualNum < forecastNum) return 'negative';
      return 'neutral';
    } catch {
      return null;
    }
  }
}

export const investingComScraper = InvestingComScraper.getInstance();
```

### **3. Unified Economic Data Service**

**File**: `server/services/unified-economic-service.ts`
```typescript
import { EnhancedMarketWatchScraper } from './enhanced-marketwatch-scraper.js';
import { InvestingComScraper } from './investing-scraper.js';
import { fredApiService } from './fred-api.js';
import type { EconomicEvent } from '../types/financial';

export class UnifiedEconomicService {
  private static instance: UnifiedEconomicService;
  private enhancedMarketWatch: EnhancedMarketWatchScraper;
  private investingScraper: InvestingComScraper;

  constructor() {
    this.enhancedMarketWatch = EnhancedMarketWatchScraper.getInstance();
    this.investingScraper = InvestingComScraper.getInstance();
  }

  static getInstance(): UnifiedEconomicService {
    if (!UnifiedEconomicService.instance) {
      UnifiedEconomicService.instance = new UnifiedEconomicService();
    }
    return UnifiedEconomicService.instance;
  }

  async getComprehensiveEconomicCalendar(): Promise<EconomicEvent[]> {
    console.log('üîÑ Fetching comprehensive economic calendar from multiple sources...');
    
    try {
      // Parallel fetching from all sources
      const [
        investingEvents,
        marketWatchEvents,
        fredUpdates
      ] = await Promise.allSettled([
        this.investingScraper.scrapeEconomicCalendar('thisweek'),
        this.enhancedMarketWatch.scrapeComprehensiveData(14),
        this.updateWithFREDData()
      ]);

      let allEvents: EconomicEvent[] = [];

      // Merge Investing.com events (primary source)
      if (investingEvents.status === 'fulfilled') {
        allEvents = [...investingEvents.value];
        console.log(`‚úÖ Investing.com: ${investingEvents.value.length} events`);
      }

      // Merge MarketWatch events (supplementary)
      if (marketWatchEvents.status === 'fulfilled') {
        const supplementaryEvents = this.mergeEvents(allEvents, marketWatchEvents.value);
        allEvents = supplementaryEvents;
        console.log(`‚úÖ MarketWatch: Added ${marketWatchEvents.value.length} events`);
      }

      // Update with FRED actual values (most authoritative)
      if (fredUpdates.status === 'fulfilled') {
        allEvents = this.enhanceWithFREDData(allEvents, fredUpdates.value);
        console.log(`‚úÖ FRED: Updated ${fredUpdates.value.length} events with official data`);
      }

      // Final filtering and sorting
      const finalEvents = this.finalizeEventList(allEvents);
      
      console.log(`üìä UNIFIED CALENDAR: ${finalEvents.length} total events (US only, medium/high importance)`);
      return finalEvents;

    } catch (error) {
      console.error('‚ùå Error in unified economic calendar:', error);
      return this.getEmergencyFallback();
    }
  }

  private async updateWithFREDData(): Promise<any[]> {
    try {
      const fredIndicators = await fredApiService.getLatestEconomicIndicators();
      return fredIndicators.map(indicator => ({
        title: indicator.title,
        actual: indicator.latestValue,
        date: indicator.latestDate,
        previous: indicator.previousValue,
        source: 'fred'
      }));
    } catch (error) {
      console.error('FRED update failed:', error);
      return [];
    }
  }

  private mergeEvents(primaryEvents: EconomicEvent[], secondaryEvents: EconomicEvent[]): EconomicEvent[] {
    const merged = [...primaryEvents];
    const primaryTitles = new Set(primaryEvents.map(e => e.title.toLowerCase()));

    // Add secondary events that don't exist in primary
    for (const event of secondaryEvents) {
      if (!primaryTitles.has(event.title.toLowerCase())) {
        merged.push(event);
      }
    }

    return merged;
  }

  private enhanceWithFREDData(events: EconomicEvent[], fredData: any[]): EconomicEvent[] {
    return events.map(event => {
      // Find matching FRED data
      const fredMatch = fredData.find(fred => 
        this.titleMatches(event.title, fred.title)
      );

      if (fredMatch) {
        return {
          ...event,
          actual: fredMatch.actual,
          previous: fredMatch.previous,
          source: `${event.source}_fred_enhanced`
        };
      }

      return event;
    });
  }

  private titleMatches(eventTitle: string, fredTitle: string): boolean {
    const eventLower = eventTitle.toLowerCase();
    const fredLower = fredTitle.toLowerCase();

    const matchTerms = [
      ['cpi', 'consumer price'],
      ['ppi', 'producer price'],
      ['retail sales', 'retail'],
      ['jobless claims', 'initial claims'],
      ['payrolls', 'nonfarm'],
      ['housing starts', 'housing'],
      ['industrial production', 'industrial']
    ];

    for (const [term1, term2] of matchTerms) {
      if ((eventLower.includes(term1) && fredLower.includes(term2)) ||
          (eventLower.includes(term2) && fredLower.includes(term1))) {
        return true;
      }
    }

    return false;
  }

  private finalizeEventList(events: EconomicEvent[]): EconomicEvent[] {
    // Remove duplicates, filter, and sort
    const uniqueEvents = this.removeDuplicates(events);
    const filteredEvents = this.applyFinalFilters(uniqueEvents);
    
    return filteredEvents.sort((a, b) => {
      // Sort by: importance (high first), then date (recent first)
      if (a.importance !== b.importance) {
        const importanceOrder = { high: 3, medium: 2, low: 1 };
        return importanceOrder[b.importance] - importanceOrder[a.importance];
      }
      return new Date(b.date).getTime() - new Date(a.date).getTime();
    });
  }

  private removeDuplicates(events: EconomicEvent[]): EconomicEvent[] {
    const seen = new Set<string>();
    return events.filter(event => {
      const key = `${event.title.toLowerCase()}-${event.date.toDateString()}`;
      if (seen.has(key)) return false;
      seen.add(key);
      return true;
    });
  }

  private applyFinalFilters(events: EconomicEvent[]): EconomicEvent[] {
    return events.filter(event => {
      // US events only
      if (event.country !== 'US') return false;
      
      // Medium and high importance only
      if (event.importance === 'low') return false;
      
      // Must have valid title
      if (!event.title || event.title.length < 5) return false;
      
      // Within reasonable date range (past 2 weeks to future 2 weeks)
      const now = new Date();
      const twoWeeksAgo = new Date(now.getTime() - 14 * 24 * 60 * 60 * 1000);
      const twoWeeksAhead = new Date(now.getTime() + 14 * 24 * 60 * 60 * 1000);
      
      return event.date >= twoWeeksAgo && event.date <= twoWeeksAhead;
    });
  }

  private getEmergencyFallback(): EconomicEvent[] {
    const today = new Date();
    return [
      {
        id: 'fallback-1',
        title: 'Initial Jobless Claims',
        description: 'Weekly unemployment insurance claims',
        date: today,
        time: '8:30 AM ET',
        country: 'US',
        category: 'employment',
        importance: 'high' as const,
        currency: 'USD',
        actual: null,
        forecast: '220K',
        previous: '218K',
        impact: null,
        source: 'emergency_fallback'
      }
    ];
  }
}

export const unifiedEconomicService = UnifiedEconomicService.getInstance();
```

### **4. Update Main Economic Data Service**

**File**: `server/services/economic-data.ts` (modify existing)
```typescript
import { unifiedEconomicService } from './unified-economic-service.js';
import type { EconomicEvent } from '../types/financial';

export class EconomicDataService {
  private static instance: EconomicDataService;

  static getInstance() {
    if (!EconomicDataService.instance) {
      EconomicDataService.instance = new EconomicDataService();
    }
    return EconomicDataService.instance;
  }

  async getEconomicEvents(): Promise<EconomicEvent[]> {
    console.log('üîÑ Getting comprehensive economic events...');
    
    try {
      // Use unified service for comprehensive data
      const events = await unifiedEconomicService.getComprehensiveEconomicCalendar();
      
      console.log(`üìä FINAL ECONOMIC CALENDAR: ${events.length} events`);
      console.log(`üìà Sources: Investing.com + MarketWatch + FRED API`);
      console.log(`üéØ Filter: US only, importance 2-3 (medium/high)`);
      
      return events;
    } catch (error) {
      console.error('‚ùå Error fetching comprehensive economic events:', error);
      return [];
    }
  }
}

export const economicDataService = EconomicDataService.getInstance();
```

### **5. Update API Route**

**File**: `server/routes.ts` (modify existing endpoint)
```typescript
// Update existing /api/economic-events route
app.get("/api/economic-events", async (req, res) => {
  try {
    console.log('üìä Fetching comprehensive economic calendar...');
    
    // Use new unified service
    const events = await economicDataService.getEconomicEvents();
    
    res.json({
      success: true,
      events,
      count: events.length,
      sources: ['investing.com', 'marketwatch', 'fred'],
      filters: 'US only, importance 2-3',
      timestamp: new Date().toISOString()
    });
    
  } catch (error) {
    console.error('‚ùå Error in economic events endpoint:', error);
    res.status(500).json({ 
      error: 'Failed to fetch economic events',
      success: false 
    });
  }
});
```

## **Expected Results**

With this enhanced system, you'll get:

‚úÖ **Comprehensive Coverage**: 50+ economic events per week instead of 15+  
‚úÖ **Actual Readings**: Both MarketWatch and Investing.com actual values  
‚úÖ **Smart Filtering**: US-only, medium/high importance (levels 2-3)  
‚úÖ **Multiple Sources**: Investing.com (primary) + MarketWatch + FRED API  
‚úÖ **Real Data**: Actual, Forecast, Previous values from all sources  
‚úÖ **Quality Control**: Deduplication, validation, and ranking  

The system will now capture events like:
- Consumer Confidence Index
- University of Michigan Sentiment  
- JOLTS Job Openings
- Durable Goods Orders
- Personal Income & Spending
- ISM Manufacturing & Services PMI
- Regional Fed Surveys (all districts)
- Construction Spending
- Factory Orders
- Business Inventories

This matches the comprehensive coverage you see in professional trading platforms!