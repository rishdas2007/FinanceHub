# **Project Specification: Thematic AI Market Commentary Enhancement**

## **Project Overview**

**Objective**: Transform the existing basic AI market commentary into a sophisticated thematic storytelling system with historical context, pattern recognition, and narrative coherence.

**Duration**: 3-4 weeks  
**Complexity**: Medium-High  
**Impact**: High - Transforms AI commentary from basic data reporting to professional-grade market analysis

---

## **Phase 1: Enhanced Prompt Structure (Week 1)**
*Quick wins with existing infrastructure*

### **1.1 Create Enhanced AI Analysis Service**

**File**: `server/services/thematic-ai-analysis.ts`
```typescript
import OpenAI from "openai";
import { db } from "../db/index.js";
import { sql } from "drizzle-orm";

interface ThematicAnalysisResult {
  bottomLine: string;
  dominantTheme: string;
  setup: string;
  evidence: string;
  implications: string;
  catalysts: string;
  contrarianView: string;
  confidence: number;
}

export class ThematicAIAnalysisService {
  private openai: OpenAI;
  
  constructor() {
    this.openai = new OpenAI({ 
      apiKey: process.env.OPENAI_API_KEY 
    });
  }

  async generateThematicAnalysis(
    marketData: any, 
    sectorData: any[], 
    economicEvents: any[],
    technicalData: any
  ): Promise<ThematicAnalysisResult> {
    
    const thematicPrompt = this.buildThematicPrompt(
      marketData, 
      sectorData, 
      economicEvents, 
      technicalData
    );
    
    const response = await this.openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: `You are a senior Wall Street analyst specializing in thematic market narratives. 
          Your analysis must follow the exact structure provided and create coherent stories from market data.
          Focus on narrative coherence over individual data points.`
        },
        {
          role: "user",
          content: thematicPrompt
        }
      ],
      response_format: { type: "json_object" },
      max_tokens: 2000,
      temperature: 0.7,
    });

    const result = JSON.parse(response.choices[0].message.content || '{}');
    
    return {
      bottomLine: result.bottomLine || "Market narrative analysis unavailable",
      dominantTheme: result.dominantTheme || "Mixed signals",
      setup: result.setup || "Market conditions are evolving",
      evidence: result.evidence || "Technical indicators show neutral readings",
      implications: result.implications || "Monitor key levels for direction",
      catalysts: result.catalysts || "Economic data and Fed policy decisions",
      contrarianView: result.contrarianView || "Alternative scenarios warrant consideration",
      confidence: Math.max(0, Math.min(1, result.confidence || 0.7))
    };
  }

  private buildThematicPrompt(
    marketData: any, 
    sectorData: any[], 
    economicEvents: any[],
    technicalData: any
  ): string {
    
    const formatNumber = (num: number) => num?.toFixed(1) || 'N/A';
    
    // Analyze dominant theme based on data patterns
    const themeAnalysis = this.analyzeMarketTheme(marketData, sectorData, technicalData);
    
    return `Generate a thematic market commentary following this EXACT structure:

## REQUIRED JSON RESPONSE FORMAT:
{
  "bottomLine": "[One sentence market thesis]",
  "dominantTheme": "[Primary market theme from options below]",
  "setup": "[2-3 sentences explaining current market story with key data points]",
  "evidence": "[Technical, sentiment, and cross-asset evidence supporting the theme]",
  "implications": "[Forward-looking conclusions from evidence combination]",
  "catalysts": "[Specific levels/events that could extend or reverse theme]",
  "contrarianView": "[Alternative interpretation of current data]",
  "confidence": [0.0-1.0 confidence score]
}

## THEME OPTIONS (choose most appropriate):
- Risk-on/risk-off rotation
- Growth vs value dynamics  
- Inflation concerns vs disinflationary forces
- Liquidity-driven momentum vs fundamental concerns
- Defensive positioning vs FOMO buying
- Sector rotation story
- Volatility regime change

## CURRENT MARKET DATA:
**SPY**: $${formatNumber(marketData.price)} (${formatNumber(marketData.changePercent)}%)
**Technical**: RSI ${formatNumber(technicalData.rsi)}, MACD ${formatNumber(technicalData.macd)}, ADX ${formatNumber(technicalData.adx)}
**Sentiment**: VIX ${formatNumber(marketData.vix)}, Put/Call ${formatNumber(marketData.putCallRatio)}, AAII Bull% ${formatNumber(marketData.aaiiBullish)}
**Volatility**: ATR ${formatNumber(technicalData.atr)}, Williams %R ${formatNumber(technicalData.willr)}

## SECTOR PERFORMANCE:
${this.formatSectorData(sectorData)}

## ECONOMIC CONTEXT:
${this.formatEconomicEvents(economicEvents)}

## NARRATIVE REQUIREMENTS:
1. Start with dominant theme identification
2. Build logical narrative arc: Setup ‚Üí Evidence ‚Üí Implications ‚Üí What to Watch
3. Connect technical, sentiment, and fundamental data points
4. Provide specific levels and catalysts
5. Include contrarian perspective
6. Use professional Wall Street language
7. Focus on forward-looking actionable insights

## STYLE GUIDELINES:
- Professional, authoritative tone
- Specific data references with context
- Logical flow between sections  
- Actionable insights for traders/investors
- Clear narrative thread throughout`;
  }

  private analyzeMarketTheme(marketData: any, sectorData: any[], technicalData: any): string {
    // Logic to auto-detect dominant theme based on data patterns
    const rsi = technicalData.rsi || 50;
    const vix = marketData.vix || 20;
    const sectorSpread = this.calculateSectorSpread(sectorData);
    
    if (vix > 25) return "Risk-off positioning";
    if (rsi > 70) return "Liquidity-driven momentum";
    if (sectorSpread > 2) return "Sector rotation story";
    
    return "Mixed market signals";
  }

  private formatSectorData(sectorData: any[]): string {
    if (!sectorData?.length) return "Sector data unavailable";
    
    const top3 = sectorData
      .sort((a, b) => b.changePercent - a.changePercent)
      .slice(0, 3)
      .map(s => `${s.name}: ${s.changePercent?.toFixed(1)}%`)
      .join(', ');
    
    const bottom3 = sectorData
      .sort((a, b) => a.changePercent - b.changePercent)
      .slice(0, 3)
      .map(s => `${s.name}: ${s.changePercent?.toFixed(1)}%`)
      .join(', ');
    
    return `Top Performers: ${top3}\nLaggards: ${bottom3}`;
  }

  private formatEconomicEvents(economicEvents: any[]): string {
    if (!economicEvents?.length) return "No major economic events today";
    
    return economicEvents
      .slice(0, 5)
      .map(event => `${event.title}: ${event.actual || 'Pending'} (vs ${event.forecast || 'N/A'} est)`)
      .join('\n');
  }

  private calculateSectorSpread(sectorData: any[]): number {
    if (!sectorData?.length) return 0;
    
    const returns = sectorData.map(s => s.changePercent || 0);
    return Math.max(...returns) - Math.min(...returns);
  }
}
```

### **1.2 Update AI Analysis API Route**

**File**: `server/routes.ts` (modify existing `/api/ai-analysis` endpoint)
```typescript
// Replace existing AI analysis route with:
app.get("/api/ai-analysis", async (req, res) => {
  try {
    console.log('ü§ñ Generating enhanced thematic AI analysis...');
    
    // Fetch all required data
    const [marketData, sectorData, economicEvents, technicalData] = await Promise.all([
      financialDataService.getLatestStockData('SPY'),
      financialDataService.getSectorData(),
      economicDataService.getEconomicEvents(),
      financialDataService.getTechnicalIndicators('SPY')
    ]);

    // Generate enhanced analysis
    const thematicService = new ThematicAIAnalysisService();
    const analysis = await thematicService.generateThematicAnalysis(
      marketData,
      sectorData,
      economicEvents,
      technicalData
    );

    // Store in database with new schema
    await storage.storeThematicAnalysis(analysis);

    res.json({
      success: true,
      analysis,
      timestamp: new Date().toISOString(),
      dataFreshness: "Real-time"
    });

  } catch (error) {
    console.error('‚ùå Error generating thematic analysis:', error);
    res.status(500).json({ 
      error: 'Failed to generate analysis',
      fallback: await generateFallbackAnalysis()
    });
  }
});
```

### **1.3 Update Database Schema**

**File**: `shared/schema.ts` (add new table)
```typescript
// Add to existing schema
export const thematicAnalysis = pgTable("thematic_analysis", {
  id: serial("id").primaryKey(),
  bottomLine: text("bottom_line").notNull(),
  dominantTheme: text("dominant_theme").notNull(),
  setup: text("setup").notNull(),
  evidence: text("evidence").notNull(),
  implications: text("implications").notNull(),
  catalysts: text("catalysts").notNull(),
  contrarianView: text("contrarian_view").notNull(),
  confidence: decimal("confidence", { precision: 3, scale: 2 }).notNull(),
  marketContext: json("market_context"), // Store raw market data used
  timestamp: timestamp("timestamp").notNull().defaultNow(),
});
```

### **1.4 Update Frontend Component**

**File**: `client/src/components/AIAnalysis.tsx`
```typescript
// Modify to display new thematic structure
interface ThematicAnalysisData {
  bottomLine: string;
  dominantTheme: string;
  setup: string;
  evidence: string;
  implications: string;
  catalysts: string;
  contrarianView: string;
  confidence: number;
}

export function AIAnalysis() {
  const { data: analysis, isLoading } = useQuery<ThematicAnalysisData>({
    queryKey: ['/api/ai-analysis'],
    refetchInterval: 5 * 60 * 1000, // 5 minutes
  });

  if (isLoading) return <LoadingSpinner />;

  return (
    <Card className="p-6">
      <h2 className="text-xl font-bold mb-4">ü§ñ AI Market Commentary</h2>
      
      {/* Bottom Line - Prominent Display */}
      <div className="bg-blue-900/20 border border-blue-500/30 rounded-lg p-4 mb-6">
        <h3 className="text-sm font-semibold text-blue-400 mb-2">BOTTOM LINE</h3>
        <p className="text-lg font-medium text-white">{analysis?.bottomLine}</p>
        <div className="flex items-center justify-between mt-2">
          <span className="text-sm text-gray-400">Theme: {analysis?.dominantTheme}</span>
          <span className="text-sm text-gray-400">
            Confidence: {((analysis?.confidence || 0) * 100).toFixed(0)}%
          </span>
        </div>
      </div>

      {/* Narrative Sections */}
      <div className="space-y-4">
        <AnalysisSection title="MARKET SETUP" content={analysis?.setup} />
        <AnalysisSection title="EVIDENCE" content={analysis?.evidence} />
        <AnalysisSection title="IMPLICATIONS" content={analysis?.implications} />
        <AnalysisSection title="KEY CATALYSTS" content={analysis?.catalysts} />
        <AnalysisSection title="CONTRARIAN VIEW" content={analysis?.contrarianView} />
      </div>
    </Card>
  );
}

function AnalysisSection({ title, content }: { title: string; content?: string }) {
  return (
    <div className="border-l-2 border-gray-600 pl-4">
      <h4 className="text-sm font-semibold text-gray-300 mb-1">{title}</h4>
      <p className="text-gray-100 text-sm leading-relaxed">{content}</p>
    </div>
  );
}
```

---

## **Phase 2: Historical Context System (Week 2)**
*Add percentile rankings and historical precedents*

### **2.1 Database Schema for Historical Context**

**File**: `shared/schema.ts` (add new tables)
```typescript
// Add these tables to existing schema
export const metricPercentiles = pgTable("metric_percentiles", {
  id: serial("id").primaryKey(),
  metricName: text("metric_name").notNull(),
  lookbackPeriod: text("lookback_period").notNull(), // '1Y', '3Y', '5Y', 'ALL'
  percentile5: decimal("percentile_5", { precision: 10, scale: 4 }),
  percentile25: decimal("percentile_25", { precision: 10, scale: 4 }),
  percentile50: decimal("percentile_50", { precision: 10, scale: 4 }),
  percentile75: decimal("percentile_75", { precision: 10, scale: 4 }),
  percentile95: decimal("percentile_95", { precision: 10, scale: 4 }),
  lastUpdated: timestamp("last_updated").notNull().defaultNow(),
  dataPoints: integer("data_points").notNull(), // Number of observations
  INDEX: [sql`(metric_name, lookback_period)`]
});

export const historicalContext = pgTable("historical_context", {
  id: serial("id").primaryKey(),
  metricName: text("metric_name").notNull(),
  metricValue: decimal("metric_value", { precision: 10, scale: 4 }).notNull(),
  contextDate: timestamp("context_date").notNull(),
  subsequentReturn1w: decimal("subsequent_return_1w", { precision: 8, scale: 4 }),
  subsequentReturn1m: decimal("subsequent_return_1m", { precision: 8, scale: 4 }),
  subsequentReturn3m: decimal("subsequent_return_3m", { precision: 8, scale: 4 }),
  marketContext: text("market_context"), // Brief description of market conditions
  timestamp: timestamp("timestamp").notNull().defaultNow(),
  INDEX: [sql`(metric_name, metric_value, context_date)`]
});
```

### **2.2 Historical Context Service**

**File**: `server/services/historical-context.ts`
```typescript
import { db } from "../db/index.js";
import { sql, eq, and, gte, lte } from "drizzle-orm";
import { metricPercentiles, historicalContext, technicalIndicators, stockData } from "../../shared/schema.js";

interface HistoricalContextResult {
  percentile: number;
  interpretation: string;
  lastSimilar?: {
    date: string;
    outcome: string;
    context: string;
  };
  narrative: string;
}

export class HistoricalContextService {
  
  async getMetricContext(
    metricName: string, 
    currentValue: number, 
    lookbackPeriods: string[] = ['1Y', '3Y', '5Y']
  ): Promise<HistoricalContextResult[]> {
    
    const contexts: HistoricalContextResult[] = [];
    
    for (const period of lookbackPeriods) {
      // Get percentile data
      const percentileData = await this.getPercentileData(metricName, period);
      const percentile = this.calculateCurrentPercentile(currentValue, percentileData);
      
      // Get interpretation
      const interpretation = this.interpretPercentile(percentile, metricName);
      
      // Find similar historical instances
      const similarInstance = await this.findSimilarInstance(metricName, currentValue, period);
      
      // Generate narrative
      const narrative = this.generateContextNarrative(
        metricName, 
        currentValue, 
        percentile, 
        period,
        similarInstance
      );
      
      contexts.push({
        percentile,
        interpretation,
        lastSimilar: similarInstance,
        narrative
      });
    }
    
    return contexts;
  }

  private async getPercentileData(metricName: string, period: string) {
    const result = await db
      .select()
      .from(metricPercentiles)
      .where(and(
        eq(metricPercentiles.metricName, metricName),
        eq(metricPercentiles.lookbackPeriod, period)
      ))
      .limit(1);
    
    return result[0] || null;
  }

  private calculateCurrentPercentile(currentValue: number, percentileData: any): number {
    if (!percentileData) return 50; // Default to median if no data
    
    const p5 = parseFloat(percentileData.percentile5);
    const p25 = parseFloat(percentileData.percentile25);
    const p50 = parseFloat(percentileData.percentile50);
    const p75 = parseFloat(percentileData.percentile75);
    const p95 = parseFloat(percentileData.percentile95);
    
    if (currentValue <= p5) return 5;
    if (currentValue <= p25) return this.interpolate(currentValue, p5, p25, 5, 25);
    if (currentValue <= p50) return this.interpolate(currentValue, p25, p50, 25, 50);
    if (currentValue <= p75) return this.interpolate(currentValue, p50, p75, 50, 75);
    if (currentValue <= p95) return this.interpolate(currentValue, p75, p95, 75, 95);
    
    return 95;
  }

  private interpolate(value: number, x1: number, x2: number, y1: number, y2: number): number {
    return y1 + (value - x1) * (y2 - y1) / (x2 - x1);
  }

  private interpretPercentile(percentile: number, metricName: string): string {
    const metric = metricName.toLowerCase();
    
    if (percentile >= 95) {
      return metric.includes('vix') ? 'extremely fearful conditions' : 'extremely elevated readings';
    } else if (percentile >= 75) {
      return metric.includes('vix') ? 'elevated fear levels' : 'above-average conditions';
    } else if (percentile <= 5) {
      return metric.includes('vix') ? 'complacent conditions' : 'extremely low readings';
    } else if (percentile <= 25) {
      return metric.includes('vix') ? 'low volatility environment' : 'below-average levels';
    } else {
      return 'near historical averages';
    }
  }

  private async findSimilarInstance(metricName: string, currentValue: number, period: string) {
    const tolerance = 0.05; // 5% tolerance
    const minValue = currentValue * (1 - tolerance);
    const maxValue = currentValue * (1 + tolerance);
    
    // Calculate date range based on period
    const periodDays = this.getPeriodDays(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - periodDays);
    
    const result = await db
      .select()
      .from(historicalContext)
      .where(and(
        eq(historicalContext.metricName, metricName),
        gte(historicalContext.metricValue, minValue),
        lte(historicalContext.metricValue, maxValue),
        gte(historicalContext.contextDate, startDate),
        lte(historicalContext.contextDate, new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)) // At least 30 days ago
      ))
      .orderBy(sql`ABS(${historicalContext.metricValue} - ${currentValue})`)
      .limit(1);
    
    if (result.length === 0) return null;
    
    const instance = result[0];
    const return1m = parseFloat(instance.subsequentReturn1m || '0');
    
    return {
      date: instance.contextDate.toISOString().split('T')[0],
      outcome: this.formatOutcome(return1m),
      context: instance.marketContext || 'Similar market conditions'
    };
  }

  private formatOutcome(return1m: number): string {
    const absReturn = Math.abs(return1m);
    const direction = return1m > 0 ? 'gained' : 'declined';
    
    if (absReturn < 2) return 'remained relatively flat over the following month';
    if (absReturn < 5) return `${direction} ${absReturn.toFixed(1)}% over the following month`;
    
    return `${direction} ${absReturn.toFixed(1)}% over the following month`;
  }

  private generateContextNarrative(
    metricName: string, 
    currentValue: number, 
    percentile: number, 
    period: string,
    similarInstance: any
  ): string {
    
    const interpretation = this.interpretPercentile(percentile, metricName);
    const precedent = similarInstance 
      ? `Last seen at similar levels in ${similarInstance.date}, which ${similarInstance.outcome}`
      : 'Readings at this level are rare in recent history';
    
    return `${metricName} at ${currentValue} is ${interpretation} (${percentile.toFixed(0)}th percentile over ${period}). ${precedent}.`;
  }

  private getPeriodDays(period: string): number {
    switch (period) {
      case '1Y': return 365;
      case '3Y': return 1095;
      case '5Y': return 1825;
      case 'ALL': return 3650; // 10 years max
      default: return 1095;
    }
  }

  // Method to populate percentile tables (run as scheduled job)
  async calculateAndStorePercentiles() {
    console.log('üìä Calculating historical percentiles...');
    
    const metrics = ['rsi', 'vix', 'macd', 'atr', 'putCallRatio'];
    const periods = ['1Y', '3Y', '5Y'];
    
    for (const metric of metrics) {
      for (const period of periods) {
        await this.calculateMetricPercentiles(metric, period);
      }
    }
    
    console.log('‚úÖ Percentile calculations complete');
  }

  private async calculateMetricPercentiles(metricName: string, period: string) {
    const periodDays = this.getPeriodDays(period);
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - periodDays);
    
    // Get historical data for this metric
    let query = '';
    if (metricName === 'vix' || metricName === 'putCallRatio') {
      query = `
        SELECT ${metricName} as value 
        FROM market_sentiment 
        WHERE timestamp >= '${startDate.toISOString()}' 
        AND ${metricName} IS NOT NULL 
        ORDER BY ${metricName}
      `;
    } else {
      query = `
        SELECT ${metricName} as value 
        FROM technical_indicators 
        WHERE timestamp >= '${startDate.toISOString()}' 
        AND ${metricName} IS NOT NULL 
        ORDER BY ${metricName}
      `;
    }
    
    const results = await db.execute(sql.raw(query));
    const values = results.map((r: any) => parseFloat(r.value)).filter(v => !isNaN(v));
    
    if (values.length < 10) return; // Not enough data
    
    // Calculate percentiles
    const percentiles = {
      percentile5: this.getPercentileValue(values, 0.05),
      percentile25: this.getPercentileValue(values, 0.25),
      percentile50: this.getPercentileValue(values, 0.50),
      percentile75: this.getPercentileValue(values, 0.75),
      percentile95: this.getPercentileValue(values, 0.95),
    };
    
    // Store in database
    await db.insert(metricPercentiles)
      .values({
        metricName,
        lookbackPeriod: period,
        ...percentiles,
        dataPoints: values.length
      })
      .onConflictDoUpdate({
        target: [metricPercentiles.metricName, metricPercentiles.lookbackPeriod],
        set: {
          ...percentiles,
          dataPoints: values.length,
          lastUpdated: new Date()
        }
      });
  }

  private getPercentileValue(sortedValues: number[], percentile: number): number {
    const index = percentile * (sortedValues.length - 1);
    const lower = Math.floor(index);
    const upper = Math.ceil(index);
    const weight = index % 1;
    
    if (upper >= sortedValues.length) return sortedValues[sortedValues.length - 1];
    
    return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;
  }
}
```

### **2.3 Enhanced Thematic Analysis with Historical Context**

**File**: `server/services/thematic-ai-analysis.ts` (update existing)
```typescript
// Add to existing ThematicAIAnalysisService class
import { HistoricalContextService } from './historical-context.js';

export class ThematicAIAnalysisService {
  private historicalContext: HistoricalContextService;
  
  constructor() {
    this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    this.historicalContext = new HistoricalContextService();
  }

  async generateThematicAnalysis(
    marketData: any, 
    sectorData: any[], 
    economicEvents: any[],
    technicalData: any
  ): Promise<ThematicAnalysisResult> {
    
    // Generate historical context for key metrics
    const contexts = await this.generateHistoricalContext(marketData, technicalData);
    
    // Build enhanced prompt with historical context
    const enhancedPrompt = this.buildEnhancedPrompt(
      marketData, 
      sectorData, 
      economicEvents, 
      technicalData,
      contexts
    );
    
    // Call OpenAI with enhanced prompt
    const response = await this.openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: `You are a senior Wall Street analyst with access to historical market data. 
          Use the provided historical context to create compelling narratives that compare current conditions to past market periods.
          Focus on precedent and pattern recognition in your analysis.`
        },
        {
          role: "user",
          content: enhancedPrompt
        }
      ],
      response_format: { type: "json_object" },
      max_tokens: 2500,
      temperature: 0.7,
    });

    const result = JSON.parse(response.choices[0].message.content || '{}');
    
    return {
      bottomLine: result.bottomLine || "Market narrative analysis unavailable",
      dominantTheme: result.dominantTheme || "Mixed signals",
      setup: result.setup || "Market conditions are evolving",
      evidence: result.evidence || "Technical indicators show neutral readings",
      implications: result.implications || "Monitor key levels for direction",
      catalysts: result.catalysts || "Economic data and Fed policy decisions",
      contrarianView: result.contrarianView || "Alternative scenarios warrant consideration",
      confidence: Math.max(0, Math.min(1, result.confidence || 0.7))
    };
  }

  private async generateHistoricalContext(marketData: any, technicalData: any) {
    const contexts: Record<string, any> = {};
    
    // Get context for key metrics
    const keyMetrics = {
      rsi: technicalData.rsi,
      vix: marketData.vix,
      putCallRatio: marketData.putCallRatio,
      atr: technicalData.atr
    };
    
    for (const [metric, value] of Object.entries(keyMetrics)) {
      if (value && !isNaN(value)) {
        try {
          const metricContexts = await this.historicalContext.getMetricContext(
            metric, 
            parseFloat(value), 
            ['3Y'] // Focus on 3-year context for primary analysis
          );
          
          if (metricContexts.length > 0) {
            contexts[metric] = metricContexts[0];
          }
        } catch (error) {
          console.error(`Error getting context for ${metric}:`, error);
        }
      }
    }
    
    return contexts;
  }

  private buildEnhancedPrompt(
    marketData: any, 
    sectorData: any[], 
    economicEvents: any[],
    technicalData: any,
    contexts: Record<string, any>
  ): string {
    
    const formatNumber = (num: number) => num?.toFixed(1) || 'N/A';
    
    // Build historical context section
    const historicalSection = Object.entries(contexts)
      .map(([metric, context]) => `**${metric.toUpperCase()}**: ${context.narrative}`)
      .join('\n');
    
    return `Generate a thematic market commentary with historical context following this EXACT structure:

## REQUIRED JSON RESPONSE FORMAT:
{
  "bottomLine": "[One sentence market thesis incorporating historical precedent]",
  "dominantTheme": "[Primary market theme from options below]",
  "setup": "[2-3 sentences explaining current story with historical comparison]",
  "evidence": "[Technical, sentiment evidence with percentile rankings and precedents]",
  "implications": "[Forward-looking conclusions based on historical patterns]",
  "catalysts": "[Specific levels/events with historical context for significance]",
  "contrarianView": "[Alternative interpretation considering historical outliers]",
  "confidence": [0.0-1.0 confidence score based on historical reliability]
}

## HISTORICAL CONTEXT FOR CURRENT READINGS:
${historicalSection}

## CURRENT MARKET DATA:
**SPY**: $${formatNumber(marketData.price)} (${formatNumber(marketData.changePercent)}%)
**Technical**: RSI ${formatNumber(technicalData.rsi)}, MACD ${formatNumber(technicalData.macd)}, ADX ${formatNumber(technicalData.adx)}
**Sentiment**: VIX ${formatNumber(marketData.vix)}, Put/Call ${formatNumber(marketData.putCallRatio)}, AAII Bull% ${formatNumber(marketData.aaiiBullish)}

## SECTOR PERFORMANCE:
${this.formatSectorData(sectorData)}

## ECONOMIC CONTEXT:
${this.formatEconomicEvents(economicEvents)}

## ENHANCED NARRATIVE REQUIREMENTS:
1. Lead with historical context - "Current conditions echo..." or "This setup resembles..."
2. Use percentile language: "RSI in Xth percentile suggests..."
3. Reference specific historical precedents when similar conditions occurred
4. Compare current outcomes to historical patterns
5. Acknowledge when current conditions are unprecedented
6. Build confidence score based on historical pattern reliability
7. Use historical context to support contrarian scenarios

## STYLE GUIDELINES:
- Start evidence section with historical percentile context
- Reference specific dates when similar conditions occurred
- Compare current setup to notable historical periods
- Use historical outcomes to inform forward-looking statements
- Acknowledge pattern reliability in confidence scoring`;
  }
}
```

---

## **Phase 3: Pattern Recognition System (Week 3)**
*Advanced pattern matching and outcome prediction*

### **3.1 Pattern Recognition Service**

**File**: `server/services/pattern-recognition.ts`
```typescript
import { db } from "../db/index.js";
import { sql, and, gte, lte, eq } from "drizzle-orm";

interface PatternMatch {
  date: string;
  similarity: number;
  subsequentReturns: {
    oneWeek: number;
    oneMonth: number;
    threeMonth: number;
  };
  marketContext: string;
  conditions: Record<string, number>;
}

interface PatternAnalysis {
  totalMatches: number;
  averageOutcomes: {
    oneWeek: number;
    oneMonth: number;
    threeMonth: number;
  };
  successRate: number;
  mostRelevantMatch: PatternMatch | null;
  patternReliability: number;
  historicalContext: string;
}

export class PatternRecognitionService {
  
  async findSimilarMarketConditions(
    currentConditions: Record<string, number>,
    tolerance: number = 0.10,
    minMatches: number = 3,
    lookbackYears: number = 5
  ): Promise<PatternAnalysis> {
    
    console.log('üîç Searching for similar market patterns...');
    
    // Define core conditions for pattern matching
    const coreMetrics = this.extractCoreMetrics(currentConditions);
    
    // Find historical matches
    const matches = await this.findHistoricalMatches(coreMetrics, tolerance, lookbackYears);
    
    if (matches.length < minMatches) {
      return this.createLowConfidenceAnalysis(matches);
    }
    
    // Analyze outcomes
    const outcomes = this.analyzePatternOutcomes(matches);
    
    // Calculate pattern reliability
    const reliability = this.calculatePatternReliability(matches, outcomes);
    
    // Find most relevant match
    const mostRelevant = this.findMostRelevantMatch(matches, coreMetrics);
    
    return {
      totalMatches: matches.length,
      averageOutcomes: outcomes,
      successRate: this.calculateSuccessRate(matches),
      mostRelevantMatch: mostRelevant,
      patternReliability: reliability,
      historicalContext: this.generateHistoricalContext(matches, outcomes)
    };
  }

  private extractCoreMetrics(conditions: Record<string, number>): Record<string, number> {
    // Focus on most predictive metrics
    const coreMetrics: Record<string, number> = {};
    
    const importantMetrics = ['rsi', 'vix', 'putCallRatio', 'atr', 'macd'];
    
    for (const metric of importantMetrics) {
      if (conditions[metric] !== undefined && !isNaN(conditions[metric])) {
        coreMetrics[metric] = conditions[metric];
      }
    }
    
    return coreMetrics;
  }

  private async findHistoricalMatches(
    coreMetrics: Record<string, number>,
    tolerance: number,
    lookbackYears: number
  ): Promise<PatternMatch[]> {
    
    const startDate = new Date();
    startDate.setFullYear(startDate.getFullYear() - lookbackYears);
    
    const endDate = new Date();
    endDate.setDate(endDate.getDate() - 21); // Exclude last 21 days to allow for outcome measurement
    
    // Build dynamic query based on available metrics
    const conditions: string[] = [];
    const values: number[] = [];
    
    Object.entries(coreMetrics).forEach(([metric, value]) => {
      const minValue = value * (1 - tolerance);
      const maxValue = value * (1 + tolerance);
      
      if (metric === 'vix' || metric === 'putCallRatio') {
        conditions.push(`ms.${metric} BETWEEN ? AND ?`);
      } else {
        conditions.push(`ti.${metric} BETWEEN ? AND ?`);
      }
      values.push(minValue, maxValue);
    });
    
    if (conditions.length === 0) {
      return [];
    }
    
    const query = `
      SELECT 
        ti.timestamp,
        ti.rsi,
        ti.macd,
        ti.atr,
        ms.vix,
        ms.put_call_ratio as putCallRatio,
        sd1.price as price_base,
        sd2.price as price_1w,
        sd3.price as price_1m,
        sd4.price as price_3m,
        'Historical Pattern' as context
      FROM technical_indicators ti
      LEFT JOIN market_sentiment ms ON DATE(ti.timestamp) = DATE(ms.timestamp)
      LEFT JOIN stock_data sd1 ON DATE(ti.timestamp) = DATE(sd1.timestamp)
      LEFT JOIN stock_data sd2 ON sd2.timestamp >= ti.timestamp + INTERVAL '7 days' 
                                AND sd2.timestamp <= ti.timestamp + INTERVAL '10 days'
      LEFT JOIN stock_data sd3 ON sd3.timestamp >= ti.timestamp + INTERVAL '30 days' 
                                AND sd3.timestamp <= ti.timestamp + INTERVAL '35 days'
      LEFT JOIN stock_data sd4 ON sd4.timestamp >= ti.timestamp + INTERVAL '90 days' 
                                AND sd4.timestamp <= ti.timestamp + INTERVAL '95 days'
      WHERE ti.timestamp BETWEEN ? AND ?
        AND ${conditions.join(' AND ')}
        AND sd1.price IS NOT NULL
        AND sd2.price IS NOT NULL
        AND sd3.price IS NOT NULL
      ORDER BY ti.timestamp DESC
      LIMIT 50
    `;
    
    const allValues = [startDate.toISOString(), endDate.toISOString(), ...values];
    
    try {
      const results = await db.execute(sql.raw(query, allValues));
      
      return results.map((row: any) => {
        const basePrice = parseFloat(row.price_base);
        const price1w = parseFloat(row.price_1w);
        const price1m = parseFloat(row.price_1m);
        const price3m = parseFloat(row.price_3m || row.price_1m); // Fallback if 3m not available
        
        const conditions: Record<string, number> = {};
        Object.keys(coreMetrics).forEach(metric => {
          conditions[metric] = parseFloat(row[metric] || 0);
        });
        
        const similarity = this.calculateSimilarity(coreMetrics, conditions);
        
        return {
          date: new Date(row.timestamp).toISOString().split('T')[0],
          similarity,
          subsequentReturns: {
            oneWeek: ((price1w - basePrice) / basePrice) * 100,
            oneMonth: ((price1m - basePrice) / basePrice) * 100,
            threeMonth: ((price3m - basePrice) / basePrice) * 100
          },
          marketContext: row.context,
          conditions
        };
      }).filter(match => match.similarity > 0.7); // Only high-similarity matches
      
    } catch (error) {
      console.error('Error finding historical matches:', error);
      return [];
    }
  }

  private calculateSimilarity(
    current: Record<string, number>, 
    historical: Record<string, number>
  ): number {
    
    const weights = {
      rsi: 0.3,
      vix: 0.3,
      putCallRatio: 0.2,
      atr: 0.1,
      macd: 0.1
    };
    
    let weightedSimilarity = 0;
    let totalWeight = 0;
    
    Object.entries(current).forEach(([metric, currentValue]) => {
      const historicalValue = historical[metric];
      const weight = weights[metric as keyof typeof weights] || 0.1;
      
      if (historicalValue !== undefined && !isNaN(historicalValue)) {
        const difference = Math.abs(currentValue - historicalValue);
        const relativeDifference = difference / Math.abs(currentValue);
        const similarity = Math.max(0, 1 - relativeDifference);
        
        weightedSimilarity += similarity * weight;
        totalWeight += weight;
      }
    });
    
    return totalWeight > 0 ? weightedSimilarity / totalWeight : 0;
  }

  private analyzePatternOutcomes(matches: PatternMatch[]) {
    if (matches.length === 0) {
      return { oneWeek: 0, oneMonth: 0, threeMonth: 0 };
    }
    
    const outcomes = matches.reduce(
      (acc, match) => ({
        oneWeek: acc.oneWeek + match.subsequentReturns.oneWeek,
        oneMonth: acc.oneMonth + match.subsequentReturns.oneMonth,
        threeMonth: acc.threeMonth + match.subsequentReturns.threeMonth
      }),
      { oneWeek: 0, oneMonth: 0, threeMonth: 0 }
    );
    
    return {
      oneWeek: outcomes.oneWeek / matches.length,
      oneMonth: outcomes.oneMonth / matches.length,
      threeMonth: outcomes.threeMonth / matches.length
    };
  }

  private calculateSuccessRate(matches: PatternMatch[]): number {
    if (matches.length === 0) return 0;
    
    const successfulMatches = matches.filter(
      match => match.subsequentReturns.oneMonth > 0
    );
    
    return (successfulMatches.length / matches.length) * 100;
  }

  private calculatePatternReliability(
    matches: PatternMatch[], 
    outcomes: { oneWeek: number; oneMonth: number; threeMonth: number }
  ): number {
    
    if (matches.length < 3) return 0.3; // Low confidence with few matches
    
    // Calculate consistency of outcomes
    const returns = matches.map(m => m.subsequentReturns.oneMonth);
    const mean = outcomes.oneMonth;
    const variance = returns.reduce((acc, ret) => acc + Math.pow(ret - mean, 2), 0) / returns.length;
    const standardDeviation = Math.sqrt(variance);
    
    // Lower standard deviation = higher reliability
    const consistencyScore = Math.max(0, 1 - (standardDeviation / 20)); // Normalize to 0-1
    
    // More matches = higher confidence
    const sampleSizeScore = Math.min(1, matches.length / 10);
    
    // Average similarity score
    const avgSimilarity = matches.reduce((acc, m) => acc + m.similarity, 0) / matches.length;
    
    return (consistencyScore * 0.4 + sampleSizeScore * 0.3 + avgSimilarity * 0.3);
  }

  private findMostRelevantMatch(
    matches: PatternMatch[], 
    currentConditions: Record<string, number>
  ): PatternMatch | null {
    
    if (matches.length === 0) return null;
    
    // Find match with highest similarity score
    return matches.reduce((best, current) => 
      current.similarity > best.similarity ? current : best
    );
  }

  private generateHistoricalContext(
    matches: PatternMatch[], 
    outcomes: { oneWeek: number; oneMonth: number; threeMonth: number }
  ): string {
    
    if (matches.length === 0) {
      return "Current market conditions appear unprecedented in recent history";
    }
    
    const avgReturn = outcomes.oneMonth;
    const direction = avgReturn > 0 ? 'gained' : 'declined';
    const magnitude = Math.abs(avgReturn);
    
    let contextualDescription = '';
    if (magnitude < 2) {
      contextualDescription = 'remained relatively flat';
    } else if (magnitude < 5) {
      contextualDescription = `${direction} modestly (${magnitude.toFixed(1)}%)`;
    } else {
      contextualDescription = `${direction} significantly (${magnitude.toFixed(1)}%)`;
    }
    
    const timeRange = this.getTimeRangeDescription(matches);
    
    return `Similar conditions occurred ${matches.length} times ${timeRange}. ` +
           `On average, markets ${contextualDescription} over the subsequent month. ` +
           `Most recent similar instance was ${matches[0]?.date}, providing ${this.getConfidenceLevel(matches.length)} confidence in this pattern.`;
  }

  private getTimeRangeDescription(matches: PatternMatch[]): string {
    if (matches.length === 0) return '';
    
    const dates = matches.map(m => new Date(m.date));
    const oldest = new Date(Math.min(...dates.map(d => d.getTime())));
    const newest = new Date(Math.max(...dates.map(d => d.getTime())));
    
    const yearSpan = newest.getFullYear() - oldest.getFullYear();
    
    if (yearSpan === 0) return 'this year';
    if (yearSpan === 1) return 'over the past year';
    return `over the past ${yearSpan} years`;
  }

  private getConfidenceLevel(matchCount: number): string {
    if (matchCount >= 10) return 'high';
    if (matchCount >= 5) return 'moderate';
    return 'limited';
  }

  private createLowConfidenceAnalysis(matches: PatternMatch[]): PatternAnalysis {
    return {
      totalMatches: matches.length,
      averageOutcomes: { oneWeek: 0, oneMonth: 0, threeMonth: 0 },
      successRate: 50, // Neutral assumption
      mostRelevantMatch: matches[0] || null,
      patternReliability: 0.2,
      historicalContext: "Current market conditions have limited historical precedent, suggesting heightened uncertainty"
    };
  }
}
```

### **3.2 Integrate Pattern Recognition into Thematic Analysis**

**File**: `server/services/thematic-ai-analysis.ts` (update existing)
```typescript
// Add to existing imports
import { PatternRecognitionService } from './pattern-recognition.js';

export class ThematicAIAnalysisService {
  private historicalContext: HistoricalContextService;
  private patternRecognition: PatternRecognitionService;
  
  constructor() {
    this.openai = new OpenAI({ apiKey: process.env.OPENAI_API_KEY });
    this.historicalContext = new HistoricalContextService();
    this.patternRecognition = new PatternRecognitionService();
  }

  async generateThematicAnalysis(
    marketData: any, 
    sectorData: any[], 
    economicEvents: any[],
    technicalData: any
  ): Promise<ThematicAnalysisResult> {
    
    // Generate historical context for key metrics
    const contexts = await this.generateHistoricalContext(marketData, technicalData);
    
    // Find similar market patterns
    const currentConditions = this.extractCurrentConditions(marketData, technicalData);
    const patternAnalysis = await this.patternRecognition.findSimilarMarketConditions(currentConditions);
    
    // Build comprehensive prompt with all context
    const comprehensivePrompt = this.buildComprehensivePrompt(
      marketData, 
      sectorData, 
      economicEvents, 
      technicalData,
      contexts,
      patternAnalysis
    );
    
    // Call OpenAI with full context
    const response = await this.openai.chat.completions.create({
      model: "gpt-4o",
      messages: [
        {
          role: "system",
          content: `You are a senior Wall Street analyst with access to comprehensive historical market data and pattern recognition. 
          Use historical context, percentile rankings, and pattern analysis to create compelling narratives.
          Your analysis should balance historical precedent with current market uniqueness.
          Adjust confidence based on pattern reliability and historical precedent strength.`
        },
        {
          role: "user",
          content: comprehensivePrompt
        }
      ],
      response_format: { type: "json_object" },
      max_tokens: 3000,
      temperature: 0.6,
    });

    const result = JSON.parse(response.choices[0].message.content || '{}');
    
    // Calculate composite confidence score
    const compositeConfidence = this.calculateCompositeConfidence(
      result.confidence || 0.7,
      patternAnalysis.patternReliability,
      contexts
    );
    
    return {
      bottomLine: result.bottomLine || "Market narrative analysis unavailable",
      dominantTheme: result.dominantTheme || "Mixed signals",
      setup: result.setup || "Market conditions are evolving",
      evidence: result.evidence || "Technical indicators show neutral readings",
      implications: result.implications || "Monitor key levels for direction",
      catalysts: result.catalysts || "Economic data and Fed policy decisions",
      contrarianView: result.contrarianView || "Alternative scenarios warrant consideration",
      confidence: compositeConfidence
    };
  }

  private extractCurrentConditions(marketData: any, technicalData: any): Record<string, number> {
    return {
      rsi: parseFloat(technicalData.rsi) || 50,
      vix: parseFloat(marketData.vix) || 20,
      putCallRatio: parseFloat(marketData.putCallRatio) || 1.0,
      atr: parseFloat(technicalData.atr) || 10,
      macd: parseFloat(technicalData.macd) || 0
    };
  }

  private buildComprehensivePrompt(
    marketData: any, 
    sectorData: any[], 
    economicEvents: any[],
    technicalData: any,
    contexts: Record<string, any>,
    patternAnalysis: any
  ): string {
    
    const formatNumber = (num: number) => num?.toFixed(1) || 'N/A';
    
    // Build historical context section
    const historicalSection = Object.entries(contexts)
      .map(([metric, context]) => `**${metric.toUpperCase()}**: ${context.narrative}`)
      .join('\n');
    
    // Build pattern analysis section
    const patternSection = `
**PATTERN ANALYSIS**: ${patternAnalysis.historicalContext}
**HISTORICAL OUTCOMES**: Average 1-month return: ${patternAnalysis.averageOutcomes.oneMonth.toFixed(1)}%
**SUCCESS RATE**: ${patternAnalysis.successRate.toFixed(0)}% of similar instances were positive
**PATTERN RELIABILITY**: ${(patternAnalysis.patternReliability * 100).toFixed(0)}% confidence
**MOST RELEVANT PRECEDENT**: ${patternAnalysis.mostRelevantMatch?.date || 'None'} - ${this.formatOutcomeDescription(patternAnalysis.mostRelevantMatch)}`;
    
    return `Generate a comprehensive thematic market commentary with full historical context and pattern analysis:

## REQUIRED JSON RESPONSE FORMAT:
{
  "bottomLine": "[One sentence thesis incorporating pattern analysis and historical precedent]",
  "dominantTheme": "[Primary theme based on historical patterns]",
  "setup": "[Setup incorporating pattern frequency and historical context]",
  "evidence": "[Evidence section with percentiles, patterns, and precedents]",
  "implications": "[Implications based on historical pattern outcomes]",
  "catalysts": "[Key levels/events with historical significance context]",
  "contrarianView": "[Contrarian view considering pattern failure scenarios]",
  "confidence": [0.0-1.0 score factoring pattern reliability and historical precedent]
}

## HISTORICAL PERCENTILE CONTEXT:
${historicalSection}

## PATTERN RECOGNITION ANALYSIS:
${patternSection}

## CURRENT MARKET DATA:
**SPY**: $${formatNumber(marketData.price)} (${formatNumber(marketData.changePercent)}%)
**Technical**: RSI ${formatNumber(technicalData.rsi)}, MACD ${formatNumber(technicalData.macd)}, ADX ${formatNumber(technicalData.adx)}
**Sentiment**: VIX ${formatNumber(marketData.vix)}, Put/Call ${formatNumber(marketData.putCallRatio)}, AAII Bull% ${formatNumber(marketData.aaiiBullish)}

## SECTOR PERFORMANCE:
${this.formatSectorData(sectorData)}

## ECONOMIC CONTEXT:
${this.formatEconomicEvents(economicEvents)}

## COMPREHENSIVE NARRATIVE REQUIREMENTS:
1. **BOTTOM LINE**: Lead with pattern-based thesis (e.g., "Current setup echoes X historical instances that averaged Y% returns")
2. **SETUP**: Integrate pattern frequency with thematic analysis
3. **EVIDENCE**: Start with historical percentiles, then current readings, then pattern precedents
4. **IMPLICATIONS**: Base forward outlook on historical pattern outcomes and reliability
5. **CATALYSTS**: Reference levels that historically triggered pattern continuation/reversal
6. **CONTRARIAN VIEW**: Consider scenarios where current pattern fails based on historical outliers
7. **CONFIDENCE**: Factor in pattern reliability score (${(patternAnalysis.patternReliability * 100).toFixed(0)}%) and sample size (${patternAnalysis.totalMatches} matches)

## ADVANCED ANALYSIS GUIDELINES:
- Distinguish between high-confidence patterns (10+ matches, >80% reliability) and low-confidence patterns
- Reference specific historical periods when patterns worked/failed
- Use pattern success rate to calibrate confidence in directional calls
- Acknowledge when current conditions are unprecedented (low match count)
- Weight recent pattern matches more heavily than distant ones
- Consider pattern deterioration scenarios in contrarian view`;
  }

  private formatOutcomeDescription(match: any): string {
    if (!match) return 'No clear precedent available';
    
    const return1m = match.subsequentReturns.oneMonth;
    const direction = return1m > 0 ? 'gained' : 'declined';
    
    return `Market ${direction} ${Math.abs(return1m).toFixed(1)}% over following month`;
  }

  private calculateCompositeConfidence(
    aiConfidence: number,
    patternReliability: number,
    contexts: Record<string, any>
  ): number {
    
    // Weight different confidence sources
    const weights = {
      ai: 0.4,           // AI model confidence
      pattern: 0.4,      // Pattern reliability
      historical: 0.2    // Historical context availability
    };
    
    // Calculate historical context score
    const contextScore = Math.min(1, Object.keys(contexts).length / 4); // Up to 4 key metrics
    
    const composite = (
      aiConfidence * weights.ai +
      patternReliability * weights.pattern +
      contextScore * weights.historical
    );
    
    return Math.max(0.1, Math.min(0.95, composite));
  }
}
```

---

## **Phase 4: Frontend Enhancements & Testing (Week 4)**

### **4.1 Enhanced Frontend Display**

**File**: `client/src/components/AIAnalysis.tsx` (complete rewrite)
```typescript
import React, { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { Card } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { TrendingUp, TrendingDown, AlertTriangle, Clock, Target, Eye } from 'lucide-react';

interface ThematicAnalysisData {
  bottomLine: string;
  dominantTheme: string;
  setup: string;
  evidence: string;
  implications: string;
  catalysts: string;
  contrarianView: string;
  confidence: number;
  timestamp: string;
  patternAnalysis?: {
    totalMatches: number;
    averageOutcomes: {
      oneMonth: number;
    };
    patternReliability: number;
    historicalContext: string;
  };
}

export function AIAnalysis() {
  const [activeTab, setActiveTab] = useState('analysis');
  
  const { data: analysis, isLoading, error } = useQuery<{
    analysis: ThematicAnalysisData;
    success: boolean;
  }>({
    queryKey: ['/api/ai-analysis'],
    refetchInterval: 5 * 60 * 1000, // 5 minutes
    refetchOnMount: true,
    staleTime: 0
  });

  if (isLoading) {
    return (
      <Card className="p-6">
        <div className="animate-pulse space-y-4">
          <div className="h-4 bg-gray-600 rounded w-3/4"></div>
          <div className="h-4 bg-gray-600 rounded w-1/2"></div>
          <div className="h-20 bg-gray-600 rounded"></div>
        </div>
      </Card>
    );
  }

  if (error || !analysis?.success) {
    return (
      <Card className="p-6 border-red-500/30 bg-red-900/10">
        <div className="flex items-center gap-2 text-red-400">
          <AlertTriangle size={20} />
          <span>AI Analysis temporarily unavailable</span>
        </div>
      </Card>
    );
  }

  const analysisData = analysis.analysis;
  const confidenceColor = getConfidenceColor(analysisData.confidence);
  const confidenceLabel = getConfidenceLabel(analysisData.confidence);

  return (
    <Card className="p-6">
      <div className="flex items-center justify-between mb-6">
        <h2 className="text-xl font-bold flex items-center gap-2">
          ü§ñ AI Market Commentary
          <Badge variant="outline" className={`${confidenceColor} text-xs`}>
            {confidenceLabel}
          </Badge>
        </h2>
        <div className="text-xs text-gray-400 flex items-center gap-1">
          <Clock size={12} />
          {new Date(analysisData.timestamp).toLocaleTimeString()}
        </div>
      </div>

      <Tabs value={activeTab} onValueChange={setActiveTab} className="w-full">
        <TabsList className="grid w-full grid-cols-3 mb-6">
          <TabsTrigger value="analysis" className="flex items-center gap-1">
            <TrendingUp size={14} />
            Analysis
          </TabsTrigger>
          <TabsTrigger value="patterns" className="flex items-center gap-1">
            <Target size={14} />
            Patterns
          </TabsTrigger>
          <TabsTrigger value="contrarian" className="flex items-center gap-1">
            <Eye size={14} />
            Contrarian
          </TabsTrigger>
        </TabsList>

        <TabsContent value="analysis" className="space-y-6">
          {/* Bottom Line - Hero Section */}
          <div className="bg-gradient-to-r from-blue-900/30 to-purple-900/30 border border-blue-500/30 rounded-lg p-4">
            <h3 className="text-sm font-semibold text-blue-400 mb-2 flex items-center gap-2">
              <TrendingUp size={16} />
              MARKET THESIS
            </h3>
            <p className="text-lg font-medium text-white leading-relaxed">
              {analysisData.bottomLine}
            </p>
            <div className="flex items-center justify-between mt-3 pt-3 border-t border-blue-500/20">
              <ThemeBadge theme={analysisData.dominantTheme} />
              <ConfidenceIndicator confidence={analysisData.confidence} />
            </div>
          </div>

          {/* Narrative Sections */}
          <div className="grid gap-4">
            <AnalysisSection 
              icon={<TrendingUp size={16} />}
              title="MARKET SETUP" 
              content={analysisData.setup}
              className="border-l-2 border-green-500"
            />
            <AnalysisSection 
              icon={<Target size={16} />}
              title="EVIDENCE" 
              content={analysisData.evidence}
              className="border-l-2 border-blue-500"
            />
            <AnalysisSection 
              icon={<TrendingUp size={16} />}
              title="IMPLICATIONS" 
              content={analysisData.implications}
              className="border-l-2 border-purple-500"
            />
            <AnalysisSection 
              icon={<AlertTriangle size={16} />}
              title="KEY CATALYSTS" 
              content={analysisData.catalysts}
              className="border-l-2 border-yellow-500"
            />
          </div>
        </TabsContent>

        <TabsContent value="patterns" className="space-y-4">
          <PatternAnalysisDisplay pattern={analysisData.patternAnalysis} />
        </TabsContent>

        <TabsContent value="contrarian" className="space-y-4">
          <div className="bg-red-900/20 border border-red-500/30 rounded-lg p-4">
            <h3 className="text-sm font-semibold text-red-400 mb-3 flex items-center gap-2">
              <Eye size={16} />
              ALTERNATIVE PERSPECTIVE
            </h3>
            <p className="text-gray-100 leading-relaxed">{analysisData.contrarianView}</p>
          </div>
        </TabsContent>
      </Tabs>
    </Card>
  );
}

function ThemeBadge({ theme }: { theme: string }) {
  const themeColors = {
    'Risk-on': 'bg-green-900/30 text-green-400 border-green-500/30',
    'Risk-off': 'bg-red-900/30 text-red-400 border-red-500/30',
    'Rotation': 'bg-purple-900/30 text-purple-400 border-purple-500/30',
    'Momentum': 'bg-blue-900/30 text-blue-400 border-blue-500/30',
    'Defensive': 'bg-yellow-900/30 text-yellow-400 border-yellow-500/30'
  };
  
  const colorClass = Object.entries(themeColors).find(([key]) => 
    theme.toLowerCase().includes(key.toLowerCase())
  )?.[1] || 'bg-gray-900/30 text-gray-400 border-gray-500/30';
  
  return (
    <Badge variant="outline" className={`${colorClass} text-xs px-2 py-1`}>
      {theme}
    </Badge>
  );
}

function ConfidenceIndicator({ confidence }: { confidence: number }) {
  const percentage = Math.round(confidence * 100);
  const color = getConfidenceColor(confidence);
  
  return (
    <div className="flex items-center gap-2">
      <div className="w-16 bg-gray-700 rounded-full h-2">
        <div 
          className={`h-2 rounded-full ${color}`}
          style={{ width: `${percentage}%` }}
        />
      </div>
      <span className="text-xs text-gray-400">{percentage}%</span>
    </div>
  );
}

function AnalysisSection({ 
  icon, 
  title, 
  content, 
  className = '' 
}: { 
  icon: React.ReactNode;
  title: string; 
  content?: string; 
  className?: string;
}) {
  return (
    <div className={`pl-4 ${className}`}>
      <h4 className="text-sm font-semibold text-gray-300 mb-2 flex items-center gap-2">
        {icon}
        {title}
      </h4>
      <p className="text-gray-100 text-sm leading-relaxed">{content}</p>
    </div>
  );
}

function PatternAnalysisDisplay({ pattern }: { pattern?: any }) {
  if (!pattern) {
    return (
      <div className="text-center py-8 text-gray-400">
        <Target size={48} className="mx-auto mb-4 opacity-50" />
        <p>Pattern analysis not available</p>
      </div>
    );
  }
  
  return (
    <div className="space-y-4">
      <div className="grid grid-cols-2 gap-4">
        <MetricCard
          title="Historical Matches"
          value={pattern.totalMatches}
          subtitle="similar periods found"
        />
        <MetricCard
          title="Average Outcome"
          value={`${pattern.averageOutcomes.oneMonth > 0 ? '+' : ''}${pattern.averageOutcomes.oneMonth.toFixed(1)}%`}
          subtitle="1-month return"
          className={pattern.averageOutcomes.oneMonth > 0 ? 'text-green-400' : 'text-red-400'}
        />
      </div>
      
      <div className="bg-gray-800/50 rounded-lg p-4">
        <h4 className="text-sm font-semibold text-gray-300 mb-2">Historical Context</h4>
        <p className="text-gray-100 text-sm leading-relaxed">{pattern.historicalContext}</p>
      </div>
    </div>
  );
}

function MetricCard({ 
  title, 
  value, 
  subtitle, 
  className = '' 
}: { 
  title: string; 
  value: string | number; 
  subtitle: string; 
  className?: string;
}) {
  return (
    <div className="bg-gray-800/30 rounded-lg p-3">
      <div className="text-xs text-gray-400 mb-1">{title}</div>
      <div className={`text-lg font-semibold ${className}`}>{value}</div>
      <div className="text-xs text-gray-500">{subtitle}</div>
    </div>
  );
}

function getConfidenceColor(confidence: number): string {
  if (confidence >= 0.8) return 'bg-green-500 text-green-100 border-green-400';
  if (confidence >= 0.6) return 'bg-yellow-500 text-yellow-900 border-yellow-400';
  return 'bg-red-500 text-red-100 border-red-400';
}

function getConfidenceLabel(confidence: number): string {
  if (confidence >= 0.8) return 'High Confidence';
  if (confidence >= 0.6) return 'Moderate Confidence';
  return 'Low Confidence';
}
```

### **4.2 Scheduled Data Population**

**File**: `server/services/data-population.ts`
```typescript
import { HistoricalContextService } from './historical-context.js';
import cron from 'node-cron';

export class DataPopulationService {
  private historicalContext: HistoricalContextService;
  
  constructor() {
    this.historicalContext = new HistoricalContextService();
  }

  startScheduledJobs() {
    console.log('üìÖ Starting scheduled data population jobs...');
    
    // Calculate percentiles daily at 2 AM
    cron.schedule('0 2 * * *', async () => {
      console.log('üîÑ Running daily percentile calculations...');
      try {
        await this.historicalContext.calculateAndStorePercentiles();
        console.log('‚úÖ Percentile calculations completed');
      } catch (error) {
        console.error('‚ùå Error in percentile calculations:', error);
      }
    });
    
    // Populate historical context weekly
    cron.schedule('0 3 * * 0', async () => {
      console.log('üîÑ Running weekly historical context population...');
      try {
        await this.populateHistoricalContext();
        console.log('‚úÖ Historical context population completed');
      } catch (error) {
        console.error('‚ùå Error in historical context population:', error);
      }
    });
  }

  private async populateHistoricalContext() {
    // Implementation for populating historical context table
    // This would analyze past market conditions and subsequent outcomes
    console.log('Populating historical context data...');
  }
}

// Add to your main server file
import { DataPopulationService } from './services/data-population.js';

const dataPopulation = new DataPopulationService();
dataPopulation.startScheduledJobs();
```

---

## **Implementation Timeline**

### **Week 1: Enhanced Prompt Structure**
- ‚úÖ Day 1-2: Create `ThematicAIAnalysisService`
- ‚úÖ Day 3-4: Update API routes and database schema
- ‚úÖ Day 5: Update frontend component, test basic thematic analysis

### **Week 2: Historical Context System**
- ‚úÖ Day 1-2: Implement `HistoricalContextService` and database tables
- ‚úÖ Day 3-4: Add percentile calculations and historical data population
- ‚úÖ Day 5: Integrate historical context into AI prompts, test percentile rankings

### **Week 3: Pattern Recognition**
- ‚úÖ Day 1-3: Build `PatternRecognitionService` with pattern matching algorithms
- ‚úÖ Day 4-5: Integrate pattern analysis into thematic analysis, test pattern outcomes

### **Week 4: Frontend & Testing**
- ‚úÖ Day 1-2: Enhanced frontend with tabs, pattern display, confidence indicators
- ‚úÖ Day 3-4: Comprehensive testing, performance optimization
- ‚úÖ Day 5: Documentation, deployment, monitoring setup

---

## **Success Metrics**

### **Technical Metrics**
- ‚úÖ AI analysis confidence scores averaging >0.7
- ‚úÖ Pattern recognition finding 5+ matches for 80% of market conditions
- ‚úÖ Historical context available for all major technical indicators
- ‚úÖ Frontend loading < 2 seconds, analysis generation < 10 seconds

### **Quality Metrics**
- ‚úÖ Commentary includes specific historical precedents in 90% of analyses
- ‚úÖ Percentile rankings provided for all technical indicators
- ‚úÖ Pattern-based forward guidance included in all analyses
- ‚úÖ Contrarian scenarios address potential pattern failures

### **Business Metrics**
- ‚úÖ Increased user engagement time on AI analysis section
- ‚úÖ Higher confidence in market analysis from user feedback
- ‚úÖ Enhanced daily email subscriber retention

---

## **Risk Mitigation**

### **Technical Risks**
- ‚úÖ **Database Performance**: Index optimization for historical queries
- ‚úÖ **API Rate Limits**: Caching strategy for OpenAI calls
- ‚úÖ **Data Quality**: Robust fallback mechanisms for missing historical data

### **Business Risks**
- ‚úÖ **Analysis Quality**: Human review process for AI outputs
- ‚úÖ **User Confusion**: Clear confidence indicators and explanation tooltips
- ‚úÖ **Market Changes**: Regular model retraining and prompt optimization

This comprehensive project specification provides a clear roadmap for implementing sophisticated thematic AI market commentary with historical context and pattern recognition. The phased approach allows for iterative testing and refinement while building toward a professional-grade analysis system.