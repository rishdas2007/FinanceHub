Summary: Composite Z-Score Calculation Issues

  ðŸš¨ Critical Issues Found

  Issue 1: Data Source Mismatch

  Root Cause: API trying to read from non-existent table
  - API expects: equity_features_daily.composite_z_60d
  - Service calculates & stores:
  zscoreTechnicalIndicators.compositeZScore
  - Result: API likely getting null values, falling back to hardcoded
  defaults

  Issue 2: Double Signal Processing

  Problem: Z-scores are being processed twice, dampening signals

  Current Flawed Process:
  1. Calculate raw z-score: (value - mean) / stdDev
  2. Convert to "signal": zscoreToSignal(zscore) (applies statistical
  thresholds)
  3. Apply component weights: weight * convertedSignal

  Better Approach:
  // Direct weighting without signal conversion
  const rawCompositeZScore = (
    (rsiZScore !== null ? this.weights.rsi * rsiZScore : 0) +
    (macdZScore !== null ? this.weights.macd * macdZScore : 0) +
    (bollingerZScore !== null ? this.weights.bollinger *
  (-bollingerZScore) : 0) +
    (maTrendZScore !== null ? this.weights.maTrend * maTrendZScore : 0) +
    (priceMomentumZScore !== null ? this.weights.priceMomentum *
  priceMomentumZScore : 0)
  );

  Issue 3: ATR Modifier Always Amplifies

  Problem: ATR modifier only increases signal strength, never dampens
  // CURRENT (PROBLEMATIC):
  const atrMultiplier = 1 + Math.abs(atrZScore) * 0.1; // Always â‰¥ 1.0

  // BETTER:
  const atrMultiplier = atrZScore > 1.0 ? 1 + (atrZScore - 1) * 0.1 : // 
  Amplify only when ATR is unusually high
                        atrZScore < -1.0 ? 1 / (1 + Math.abs(atrZScore +
  1) * 0.1) : // Dampen when ATR is unusually low
                        1.0; // Normal volatility

  Issue 4: Signal Thresholds May Be Wrong

  Current thresholds: BUY â‰¤ -1.0, SELL â‰¥ 1.0
  Issue: If your composite z-score calculation is dampened, these
  thresholds might be too strict

  From your screenshot showing values like 0.8000, the calculation might
  be producing compressed values that rarely exceed Â±1.0.

  Fix Implementation Plan

  Priority 1: Fix Data Source (15 minutes)

  -- Check what table actually has the z-score data
  SELECT table_name, column_name
  FROM information_schema.columns
  WHERE column_name LIKE '%composite%' OR column_name LIKE '%zscore%';

  -- Verify which table has recent z-score data
  SELECT COUNT(*) FROM zscoreTechnicalIndicators WHERE date >=
  CURRENT_DATE - INTERVAL '7 days';

  Priority 2: Update API Endpoint (10 minutes)

  File: server/routes/etf-enhanced-routes.ts:99
  // CHANGE FROM:
  const compositeZ = features?.composite_z_60d ?
  Number(features.composite_z_60d) : null;

  // CHANGE TO: (use correct table/column)
  const compositeZ = features?.compositeZScore ?
  Number(features.compositeZScore) : null;

  Priority 3: Fix Double Processing (20 minutes)

  File: server/services/zscore-technical-service.ts:432-443
  // Remove zscoreToSignal() wrapper and use raw z-scores
  const rawCompositeZScore = (
    (rsiZScore !== null ? this.weights.rsi * rsiZScore : 0) +
    (macdZScore !== null ? this.weights.macd * macdZScore : 0) +
    (bollingerZScore !== null ? this.weights.bollinger *
  (-bollingerZScore) : 0) +
    (maTrendZScore !== null ? this.weights.maTrend * maTrendZScore : 0) +
    (priceMomentumZScore !== null ? this.weights.priceMomentum *
  priceMomentumZScore : 0)
  );

  Priority 4: Adjust Signal Thresholds (5 minutes)

  // More sensitive thresholds for direct z-score composite
  if (compositeZScore <= -0.75) signal = 'BUY';
  else if (compositeZScore >= 0.75) signal = 'SELL';

  Expected Result: More realistic z-scores (like XLV's 0.1702) instead of
   the repeating 0.8000 values, and more varied BUY/SELL signals based on
   actual statistical thresholds