üöÄ Revised Backfill Strategy: Twelve Data (144/min) + FRED (120/min)

  üìä UPDATED API CAPACITY ANALYSIS

  Rate Limit Comparison

  const API_LIMITS = {
    twelveData: {
      callsPerMinute: 144,
      callsPerHour: 8640,
      callsPerDay: 207360,
      optimalRate: 120,        // Leave 24 call buffer
      delayBetweenCalls: 500   // 500ms = 120 calls/minute
    },
    fred: {
      callsPerMinute: 120,
      callsPerHour: 7200,
      callsPerDay: 172800,
      optimalRate: 100,        // Leave 20 call buffer
      delayBetweenCalls: 600   // 600ms = 100 calls/minute
    }
  };

  Backfill Time Estimates

  const BACKFILL_ESTIMATES = {
    // Twelve Data (Equity/ETF data)
    equityData: {
      symbolsCount: 15,         // SPY, QQQ, IWM + 12 sector ETFs
      yearsPerSymbol: 5,        // 5 years historical
      callsPerSymbol: 1260,     // 252 trading days √ó 5 years
      totalCalls: 18900,        // 15 symbols √ó 1260 calls
      estimatedTime: '2.6 hours' // 18900 √∑ (120 calls/min √ó 60 min)
    },

    // FRED (Economic data)
    economicData: {
      indicatorsCount: 80,      // All economic indicators
      yearsPerIndicator: 10,    // 10 years historical
      callsPerIndicator: 120,   // Monthly data: 12 √ó 10 years
      totalCalls: 9600,         // 80 √ó 120 calls
      estimatedTime: '1.6 hours' // 9600 √∑ (100 calls/min √ó 60 min)
    },

    // Total backfill time
    totalEstimate: '4.2 hours' // Sequential execution
  };

  ---
  üéØ OPTIMIZED EXECUTION STRATEGY

  Phase 1: Parallel API Utilization (Recommended)

  Since both APIs have similar limits, run them in parallel:

  const PARALLEL_EXECUTION_PLAN = {
    timeline: 'Simultaneous execution',

    stream1: {
      api: 'Twelve Data',
      task: 'Equity/ETF historical data + technical indicators',
      rate: '120 calls/minute',
      duration: '2.6 hours'
    },

    stream2: {
      api: 'FRED',
      task: 'Economic indicators historical data',
      rate: '100 calls/minute',
      duration: '1.6 hours'
    },

    totalTime: '2.6 hours', // Limited by slower stream
    efficiency: '94%'        // Much better than 4.2 hours sequential
  };

  Phase 2: Intelligent Prioritization

  Twelve Data Priority Order:
  1. Market Indices (30 minutes): SPY, QQQ, IWM
  2. Core Sectors (90 minutes): XLF, XLK, XLV, XLE (most important)
  3. Remaining Sectors (60 minutes): XLI, XLY, XLP, XLB, XLRE, XLU, XLC

  FRED Priority Order:
  1. GDP & Growth (15 minutes): GDP, Industrial Production, Retail Sales
  2. Employment (20 minutes): Unemployment, Payrolls, Claims
  3. Inflation (25 minutes): CPI, PPI, PCE indices
  4. Monetary Policy (20 minutes): Fed Funds, Treasury yields
  5. Housing & Sentiment (40 minutes): Housing data, Consumer sentiment

  ---
  üîß REVISED RATE LIMITING CONFIGURATION

  Update your existing rate limiter:

  // server/services/rate-limiting-service.ts - Updated configuration
  private initializeConfig(): void {
    this.config.set('twelve_data', {
      requests: 120,      // Conservative limit (24 call buffer)
      window: 60 * 1000,  // 1 minute
      burst: 5            // Small burst allowance
    });

    this.config.set('fred_api', {
      requests: 100,      // Conservative limit (20 call buffer) 
      window: 60 * 1000,  // 1 minute
      burst: 3            // Small burst allowance
    });

    // Add backfill-specific configurations
    this.config.set('twelve_data_backfill', {
      requests: 115,      // Aggressive for backfill (save 29 calls)
      window: 60 * 1000,
      burst: 0            // No burst during backfill
    });

    this.config.set('fred_backfill', {
      requests: 110,      // Aggressive for backfill (save 10 calls)
      window: 60 * 1000,
      burst: 0            // No burst during backfill
    });
  }

  ---
  üìã EXECUTION SCRIPT

  Create a comprehensive backfill orchestrator:

  // server/scripts/execute-optimized-backfill.ts
  import { TwelveDataHistoricalCollector } from '../services/twelve-data-historical-collector';
  import { FREDHistoricalCollector } from '../services/fred-historical-collector';
  import { CentralizedZScoreService } from '../services/centralized-zscore-service';

  interface BackfillConfig {
    equitySymbols: string[];
    economicIndicators: string[];
    yearsBack: number;
    parallelExecution: boolean;
  }

  class OptimizedBackfillOrchestrator {
    private twelveDataCollector: TwelveDataHistoricalCollector;
    private fredCollector: FREDHistoricalCollector;
    private zScoreService: CentralizedZScoreService;

    constructor() {
      this.twelveDataCollector = TwelveDataHistoricalCollector.getInstance();
      this.fredCollector = FREDHistoricalCollector.getInstance();
      this.zScoreService = CentralizedZScoreService.getInstance();
    }

    async executeOptimizedBackfill(config: BackfillConfig): Promise<void> {
      console.log('üöÄ Starting optimized dual-API backfill operation...');
      console.log(`üìä Equity symbols: ${config.equitySymbols.length}`);
      console.log(`üìà Economic indicators: ${config.economicIndicators.length}`);
      console.log(`üìÖ Years back: ${config.yearsBack}`);
      console.log(`‚ö° Parallel execution: ${config.parallelExecution}`);

      const startTime = Date.now();

      try {
        if (config.parallelExecution) {
          // Execute both APIs simultaneously
          await Promise.all([
            this.executeTwelveDataBackfill(config.equitySymbols, config.yearsBack),
            this.executeFREDBackfill(config.economicIndicators, config.yearsBack)
          ]);
        } else {
          // Execute sequentially (fallback)
          await this.executeTwelveDataBackfill(config.equitySymbols, config.yearsBack);
          await this.executeFREDBackfill(config.economicIndicators, config.yearsBack);
        }

        // Phase 3: Calculate Z-scores from collected data
        console.log('üßÆ Phase 3: Calculating Z-scores from historical data...');
        await this.calculateHistoricalZScores(config.equitySymbols);

        const duration = Date.now() - startTime;
        console.log(`‚úÖ Optimized backfill completed in ${Math.round(duration / 1000 / 60)} minutes`);

      } catch (error) {
        console.error('‚ùå Optimized backfill failed:', error);
        throw error;
      }
    }

    private async executeTwelveDataBackfill(symbols: string[], yearsBack: number): Promise<void> {
      console.log('üìà Stream 1: Twelve Data backfill starting...');

      const estimatedCalls = symbols.length * 252 * yearsBack;
      const estimatedMinutes = Math.ceil(estimatedCalls / 120);

      console.log(`üî¢ Estimated API calls: ${estimatedCalls.toLocaleString()}`);
      console.log(`‚è±Ô∏è Estimated time: ${estimatedMinutes} minutes`);

      await this.twelveDataCollector.executeComprehensiveBackfill(symbols, yearsBack);
      console.log('‚úÖ Stream 1: Twelve Data backfill completed');
    }

    private async executeFREDBackfill(indicators: string[], yearsBack: number): Promise<void> {
      console.log('üìä Stream 2: FRED backfill starting...');

      const estimatedCalls = indicators.length * 12 * yearsBack; // Monthly data
      const estimatedMinutes = Math.ceil(estimatedCalls / 100);

      console.log(`üî¢ Estimated API calls: ${estimatedCalls.toLocaleString()}`);
      console.log(`‚è±Ô∏è Estimated time: ${estimatedMinutes} minutes`);

      await this.fredCollector.executeComprehensiveBackfill(indicators, yearsBack);
      console.log('‚úÖ Stream 2: FRED backfill completed');
    }

    private async calculateHistoricalZScores(symbols: string[]): Promise<void> {
      for (const symbol of symbols) {
        try {
          await this.zScoreService.calculateHistoricalZScoresForSymbol(symbol);
          console.log(`‚úÖ Z-scores calculated for ${symbol}`);
        } catch (error) {
          console.error(`‚ùå Z-score calculation failed for ${symbol}:`, error);
        }
      }
    }
  }

  // Main execution
  async function main() {
    const orchestrator = new OptimizedBackfillOrchestrator();

    const config: BackfillConfig = {
      equitySymbols: [
        'SPY', 'QQQ', 'IWM',  // Market indices
        'XLF', 'XLK', 'XLV', 'XLE', 'XLI', 'XLY', 'XLP', 'XLB', 'XLRE', 'XLU', 'XLC' // Sectors
      ],
      economicIndicators: [
        'GDP', 'UNRATE', 'CPIAUCSL', 'PAYEMS', 'HOUST', 'RSAFS', 'INDPRO', 'UMCSENT'
        // ... add all 80 indicators
      ],
      yearsBack: 5,
      parallelExecution: true
    };

    await orchestrator.executeOptimizedBackfill(config);
  }

  if (require.main === module) {
    main().then(() => process.exit(0)).catch(error => {
      console.error('Backfill failed:', error);
      process.exit(1);
    });
  }

  ---
  üí° COST & EFFICIENCY OPTIMIZATIONS

  1. Smart Caching Strategy

  // Avoid redundant API calls by checking existing data first
  const dataCacheStrategy = {
    checkExistingData: true,       // Query DB before API calls
    fillGapsOnly: true,           // Only fetch missing date ranges
    deduplication: true,          // Prevent duplicate records
    incrementalUpdates: true      // Daily updates after backfill
  };

  2. Error Recovery & Retry Logic

  const errorHandling = {
    retryAttempts: 3,            // Retry failed requests
    exponentialBackoff: true,    // 1s, 2s, 4s delays
    circuitBreaker: true,        // Stop after 10 consecutive failures
    partialSuccess: true,        // Continue with other symbols if one fails
    progressPersistence: true    // Resume from last successful point
  };

  3. Resource Monitoring

  const monitoring = {
    apiCallTracking: true,       // Track usage against limits
    performanceMetrics: true,    // Monitor throughput and latency
    errorReporting: true,        // Log all failures for analysis
    progressReporting: true,     // Real-time progress updates
    costTracking: false         // Both APIs are unlimited plans
  };

  ---
  üéØ EXECUTION COMMAND

  Run the optimized backfill:

  # Development/testing (1 year, limited symbols)
  npm run backfill:test

  # Production backfill (5 years, all symbols)
  npm run backfill:production

  # Monitor progress in real-time
  npm run backfill:monitor

  Expected Results:
  - Total time: ~2.6 hours (parallel execution)
  - API calls: ~28,500 total across both APIs
  - Data collected: 1.26M equity records + 9,600 economic records
  - Z-score accuracy: 95%+ confidence levels
  - Storage used: ~150-200 MB database space

  This revised strategy efficiently utilizes both your API plans while respecting their rate limits and maximizing parallel throughput!