Nice work cutting those 12 per-row sparkline calls—that was the big blocker. A few downstream ripples to watch for:

# What your change affects

1. **API contract & consumers**

   * If you removed `/api/etf/sparkline` (or similar), make sure **no other view** still calls it (modal charts, CSV/PNG export, watchlist panes, tests).
   * Your **metrics endpoint** is now the sole source. If a feature later expects a mini-series, add it there as a **batched, optional field** (e.g., `sparkMiniClose` or `sparkMiniZ`) so you don’t reintroduce N+1.

2. **Data semantics of “30-day trend”**

   * Are you plotting **calendar 30 days** or **\~21 trading days**? Previously our math used trading days. Mixing them will skew slopes around holidays/weekends.
   * Ensure the window aligns with features: if your z-score window is 60 **trading** days, the 30-day trend should also be **trading-day based** for consistency.

3. **Freshness & cache invalidation**

   * If the trend is derived from values in the metrics payload, verify the **react-query `staleTime`** lines up with your server cache TTL (we used \~60–120s). Too long = stale trend; too short = unnecessary re-renders.
   * When the user hits “Refresh All Data,” confirm you **invalidate the metrics query key** so memoized rows actually update.

4. **Memoization traps**

   * `React.memo(Row)` only helps if props are **stable by identity**. Common foot-gun:

     * Passing new objects/functions each render (`onClick={() => …}`, `style={{…}}`, `row={ {...r} }`) defeats memoization.
   * Use `useCallback` for handlers and pass **primitive props** where possible. Stable key recommendation:

     ```tsx
     <Row
       key={row.symbol}
       symbol={row.symbol}
       price={row.price}
       pct={row.pctChange}
       z={row.compositeZ}
       updatedAt={meta?.updatedAt ?? row.asof_date}
     />
     ```
   * If you sort/filter, ensure list virtualization (e.g., `react-virtual`) still receives the **same item identity** or it will re-render all rows.

5. **Color orientation still correct?**

   * If the new trend cell reuses component z’s, keep polarity:

     * MACD/MA-gap/Mom → **+z green**
     * RSI/%B → **−z green**
   * Don’t accidentally recolor off raw RSI or %B instead of the oriented z.

6. **SSR/hydration & time zones**

   * If you render the 30-day trend client-side, great. If you pre-render, confirm the **date parsing** uses UTC and not local (we learned the hard way: `toISOString()` on non-Date blows up). ET fallback still applies in headers.

7. **Remove dead code & tests**

   * Delete the old sparkline service/imports to avoid accidental re-adds and **update tests** that mocked the sparkline endpoint.

8. **Accessibility and layout stability**

   * Replace the old loading skeleton for sparklines with a small placeholder so the row height doesn’t shift.

# Quick regression checklist (5 minutes)

* **Network**: Verify only **1 request** hits `/api/etf-metrics` on first paint; no hidden per-symbol calls.
* **Latency**: Dashboard FP < 1s; metrics tile data in < 300ms warm.
* **Refresh**: Clicking “Refresh All Data” triggers `queryClient.invalidateQueries(['etf-metrics','60D'])` and rows update (memoization doesn’t block).
* **Empty/partial data**: If a symbol is missing a field (null z), the row still renders and labels show “—”.
* **Sorting/filters**: Changing sort or preset reorders without re-fetching or re-rendering all rows (check React DevTools highlights).
* **Other features**: Modal/Export/Alerts that used sparkline still work or are intentionally hidden.

# Optional hardening (keeps perf without future regressions)

* **Add a compact series to the metrics payload** (still batched):

  ```ts
  // server: include 21 trading-day closes (integers) to draw the spark
  sparkMiniClose: number[]   // length ~21, already ordered
  ```

  That gives you chartable data without another route, and you can gzip it well.

* **Guard memoization with a row-level equality**:

  ```ts
  export default React.memo(Row, (a, b) =>
    a.symbol === b.symbol &&
    a.price === b.price &&
    a.pct === b.pct &&
    a.z === b.z &&
    a.updatedAt === b.updatedAt
  );
  ```

* **Telemetry**: add a client metric for tile render time and rows rendered; compare before/after to prove the win.

If you want, paste the component that renders the ETF table header + row, and I’ll annotate exactly where to stabilize props and where a `useMemo` will help the derived 30-day spark math without re-renders.
