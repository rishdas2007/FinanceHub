Love it. Here’s a tight implementation plan your analyst can follow to replace the pop-up charts with **inline 12-month sparklines** in the Economic Indicators section, reusing the same pattern as the ETF “30-Day Trend” column.

---

# Goal

* Add a **“12M Trend”** column to the Economic Indicators table.
* Tiny, always-visible sparkline per row (no modal on click).
* Pulls from **Silver** (`econ_series_observation`) with the right transform (LEVEL or YOY) for each series.
* Works for daily/weekly/monthly/quarterly series; caches for speed; never fabricates data.

---

# Server changes (new API, cache, and resampling)

## 1) Route (new)

Create: **`GET /api/econ/sparkline?seriesId=CPILFESL&months=12&transform=LEVEL`**

**Response (contract):**

```json
{
  "success": true,
  "data": [
    { "t": 1733011200000, "date": "2024-12-01", "value": 0.0331 },
    ...
  ],
  "meta": { "seriesId": "CPILFESL", "transform": "YOY", "freq": "M" },
  "cached": true
}
```

* Always return `{ success: true, data: [] }` on miss (no `{error:...}`).
* Cache key: `econ:spark:<seriesId>:<transform>:<months>:v1` (TTL 15–60 min).
* If DB error, serve lastGood snapshot for ≤10 min.

## 2) Service logic

* **Inputs:** `seriesId` (required), `months` (default 12), `transform` (default from `econ_series_def.default_transform`, else `LEVEL`).
* **Query Silver** for the window:

  * Base filter: `period_end >= (date_trunc('month', now()) - interval '<months> months')`
  * Match `series_id = $1 AND transform_code = $2`
* **Resampling / roll-up** to 1 point per month (so daily/weekly series don’t explode the chart):

  * For **Daily/Weekly**: pick the **last observation in each month**.
  * For **Monthly**: keep each month’s point as is.
  * For **Quarterly**: keep quarter-end months (you’ll see \~4 points; acceptable for a sparkline).
* **SQL sketch (Postgres):**

```sql
with raw as (
  select period_end::date as pe, value_std
  from econ_series_observation
  where series_id = $1
    and transform_code = $2
    and period_end >= date_trunc('month', current_date) - ($3 || ' months')::interval
),
bucket as (
  select date_trunc('month', pe) as m_end, pe, value_std
  from raw
),
last_per_month as (
  select distinct on (m_end) m_end::date as period_end, value_std
  from bucket
  order by m_end, pe desc
)
select period_end, value_std
from last_per_month
order by period_end asc;
```

* **Normalize** to:

  * `t = epoch ms` (`Date.parse(period_end)`),
  * `date = YYYY-MM-DD`,
  * `value = value_std` (already in canonical units).

## 3) Indexes (if not already)

```sql
create index if not exists idx_eso_series_tr_end
  on econ_series_observation (series_id, transform_code, period_end desc);
```

---

# Client changes (reuse the ETF sparkline cell)

## 4) Reusable cell

If your ETF table already has a `SparklineCell`, make it accept a **fetcher** and **params**.

```tsx
// <SparklineCell api="/api/econ/sparkline" params={{ seriesId, months:12, transform }} />
// expects data: [{t, value}]
```

* Ensure the chart uses a **numeric X-axis**:

```tsx
<XAxis type="number" dataKey="t" hide />
<YAxis hide domain={['dataMin','dataMax']} />
<Area dataKey="value" /* keep your minimalist styles */ />
```

## 5) Add the column to Economic Indicators table

* Extend your row model to include:

  * `seriesId` (from `econ_series_def`),
  * `defaultTransform` (from def),
  * (optional) `freq` if you present it anywhere.

* Column definition:

```tsx
{
  header: '12M Trend',
  id: 'trend12m',
  cell: ({ row }) => (
    <SparklineCell
      api="/api/econ/sparkline"
      params={{
        seriesId: row.original.seriesId,
        months: 12,
        transform: row.original.defaultTransform ?? 'LEVEL'
      }}
    />
  ),
  enableSorting: false,
  size: 140
}
```

* Remove/disable the **onClick** that opened the modal for this column.

## 6) Empty & loading states

* While loading: show a tiny skeleton bar.
* If `data.length === 0`: show a faint dash (`—`) and a tooltip “No data”.

---

# Optional polish (low effort, high payoff)

* **Downsample guard**: If a series is truly daily and very dense (e.g., DFF), server can reduce to \~24 points using month-end only (already handled above). For quarterly series you’ll naturally see 4 points—fine for a sparkline.
* **Transform choice**: For a few series, you might prefer `YOY` for the sparkline (CPI, PCE, PPI, INDPRO, Retail, Housing). Use `default_transform` from `econ_series_def` so it’s consistent with the table’s “Level/Trend/Multi-signal” semantics.
* **Tooltip**: If you keep a hover tooltip, format using your **unit formatter** (unit from `econ_series_def.standard_unit`). The sparkline uses the same value as the table row so there’s no unit mismatch.

---

# Acceptance criteria

* The Economic Indicators table renders a **new “12M Trend” column** with tight sparklines.
* No pop-ups when clicking the sparkline (the modal can remain for other columns if you want).
* API `/api/econ/sparkline` returns `{success:true,data:[{t,date,value}]}` in <100ms from cache, <300ms cold.
* Daily/Weekly series show **one point per month** (month-end), Monthly series show each month, Quarterly show 4 points.
* No `{error:...}` responses; empty series return `{success:true,data:[]}` and the UI shows a non-blocking empty state.

---

If you want, I can draft a tiny PR with:

* the new **express controller/service** for `/api/econ/sparkline`,
* the **SQL** using the `last_per_month` pattern,
* and the **table column** wired to your existing `SparklineCell`.
