Good news: your API is healthy. The empty tile is almost certainly a **frontend consumption bug**‚Äîeither a tiny **route mismatch** or a **payload-shape mismatch**. Your log:

> ‚Äúüîç API Response for **/api/etf-metrics** ‚Ä¶ hasData\:true ‚Ä¶ keys:\[‚Ä¶]
> üîç Fresh ETF Data Extraction ‚Ä¶ hasResponse\:true ‚Ä¶‚Äù

‚Ä¶means the network call worked and returned an object, but your table still renders the ‚ÄúNo ETF data available‚Äù state because the rows array you feed the grid is `undefined`/`[]`.

Here‚Äôs a tight, low-risk fix.

---

# 1) Make the route unbreakable (alias both paths)

It‚Äôs easy to end up calling `/api/etf-metrics` in prod and `/api/etf/metrics` locally. Support **both**.

```ts
// server/routes/index.ts
import { getEtfMetrics } from '../controllers/etf-metrics.controller.js';

// keep both to avoid subtle 404s / empty states
router.get('/api/etf/metrics', getEtfMetrics);
router.get('/api/etf-metrics', getEtfMetrics);
```

Deploy this so either path returns the same stable payload.

---

# 2) Normalize the payload in the client (handles all shapes)

Drop this in your fetch hook and the grid will render regardless of whether the server returns
`{data:{rows:‚Ä¶}}`, `{data:{benchmark,signals}}`, `{rows:‚Ä¶}`, or a raw array.

```ts
// client/src/hooks/useEtfMetrics.ts
import { useQuery } from '@tanstack/react-query';

type EtfRow = Record<string, any>;

function normalizeEtfMetrics(json: any): EtfRow[] {
  // Accept multiple server shapes and unify to an array of rows
  const d = json?.data ?? json;

  if (Array.isArray(d)) return d as EtfRow[];
  if (Array.isArray(d?.rows)) return d.rows as EtfRow[];
  if (Array.isArray(d?.items)) return d.items as EtfRow[];

  // movers-style payload
  if (d && (Array.isArray(d.signals) || d.benchmark)) {
    const rows: EtfRow[] = [];
    if (d.benchmark && d.benchmark.symbol) rows.push(d.benchmark);
    if (Array.isArray(d.signals)) rows.push(...d.signals);
    return rows;
  }

  // older payloads
  if (Array.isArray(d?.data)) return d.data as EtfRow[];

  return [];
}

export function useEtfMetrics() {
  return useQuery({
    queryKey: ['etf-metrics','60D'],
    queryFn: async () => {
      // Use the dashed route (since your log shows /api/etf-metrics). The alias above makes both valid.
      const res = await fetch('/api/etf-metrics?horizon=60D', { headers: { 'Accept': 'application/json' }});
      const json = await res.json();

      // Optional debug to surface shape in prod if empty
      const rows = normalizeEtfMetrics(json);
      if (!rows.length && json?.warning) console.info('[etf-metrics] warning:', json.warning, json);
      if (!rows.length && process.env.NODE_ENV !== 'production') console.warn('[etf-metrics] empty, keys=', Object.keys(json?.data ?? json));
      return rows;
    },
    staleTime: 60_000
  });
}
```

And in your table component:

```tsx
const { data: rows, isLoading, isError } = useEtfMetrics();

if (isError)   return <ErrorTile title="ETF Technical Metrics" subtitle="Failed to load" />;
if (isLoading) return <Skeleton />;

if (!rows || rows.length === 0) {
  return <EmptyTile title="ETF Technical Metrics" subtitle="No ETF data available" />;
}

// render the grid with `rows`
```

---

# 3) Server: return a **stable** shape (optional but ideal)

Standardize your controller so clients always get `{ success:true, data:{ rows:[‚Ä¶], meta:{‚Ä¶} } }`. That prevents future drift.

```ts
// server/controllers/etf-metrics.controller.ts
export const getEtfMetrics = async (req, res) => {
  try {
    const rows = await buildEtfMetrics(/* ‚Ä¶ */);   // your batched query
    return res.json({ success: true, data: { rows, meta: { count: rows.length, horizon: '60D' } } });
  } catch (e) {
    console.error('[etf-metrics] fatal', e);
    return res.json({ success: true, data: { rows: [], meta: { count: 0 } }, warning: 'data_unavailable' });
  }
};
```

---

# 4) Quick validation (2 mins)

* In the browser **Network** tab, open `/api/etf-metrics?horizon=60D` and check the **body**.
  You should now see the table populated even if the body is `{data:{benchmark,signals}}` or `{data:{rows:‚Ä¶}}`.

* If it‚Äôs still empty, paste the actual `Object.keys(json?.data ?? json)` from your console log and I‚Äôll give you the one-liner tweak for the normalizer.

---

## Why this fixes it

* The alias removes any subtle **route mismatch** between environments.
* The normalizer neutralizes **payload shape differences** so the UI is robust to server changes.
* The stable server shape keeps you from chasing this again later.

Want me to also add a tiny Jest test that loads a few historical payloads and asserts the normalizer always returns a non-empty row array?
