Got it — the UI is fine now, but your **ETF metrics endpoint is failing at the DB hop**. Let’s fix that in two sweeps: (A) make the connection 100% reliable for Neon/Postgres, (B) fail‑soft so the table never bricks again.

---

## A) Hard‑fix the DB connection (Neon‑safe)

**1) Ensure SSL is on (both URL & client)**

* `DATABASE_URL` **must** end with `?sslmode=require`
* The `pg` pool must accept Neon’s TLS:

```ts
// server/db.ts
import { Pool } from 'pg';
import { drizzle } from 'drizzle-orm/node-postgres';

const pool = new Pool({
  connectionString: process.env.DATABASE_URL, // …?sslmode=require
  ssl: { rejectUnauthorized: false },
  max: 3,                       // Neon/serverless safe
  idleTimeoutMillis: 10000,
  connectionTimeoutMillis: 5000,
});
pool.on('error', (e) => console.error('PG client error', e)); // don’t crash process

export const db = drizzle(pool);
export const pg = pool;
```

**2) Test on boot (log loudly, don’t exit)**

```ts
// server/index.ts (after creating pool)
pg.query('select 1')
  .then(() => console.log('DB OK'))
  .catch(err => console.error('DB CONNECT FAIL', err.message));
```

If your env is missing, log it:

```ts
['DATABASE_URL'].forEach(k => { if (!process.env[k]) console.error('ENV MISSING:', k); });
```

**3) If you see “relation … does not exist”, run migrations**

```bash
npm run db:migrate   # or your drizzle migration cmd
```

(Your metrics query touches `technical_indicators` / `historical_stock_data`; make sure they exist.)

---

## B) Make `/api/etf-metrics` fail‑soft (never show the red box again)

**Controller: always return an array; never `null`; cache last good result.**

```ts
// server/controllers/etf-metrics.ts
let lastGood: any[] = [];
let lastGoodAt = 0;

app.get('/api/etf-metrics', async (req, res) => {
  try {
    const metrics = await etfMetricsService.getAllMetrics(/* symbols, horizon, etc. */);
    const safe = Array.isArray(metrics) ? metrics : [];
    if (safe.length) { lastGood = safe; lastGoodAt = Date.now(); }
    return res.json({ success: true, data: safe, cached: false });
  } catch (e:any) {
    console.error('ETF METRICS DB ERROR:', e?.message);
    if (lastGood.length && Date.now() - lastGoodAt < 10 * 60 * 1000) {
      // serve cached snapshot for up to 10 min
      return res.json({ success: true, data: lastGood, cached: true, warning: 'db_unavailable' });
    }
    // optional: compute minimal live metrics from TwelveData as a fallback
    return res.json({ success: true, data: [], warning: 'db_unavailable' });
  }
});
```

**Service: never return `null`; catch DB errors inside.**

```ts
// server/services/etf-metrics-service.ts
export async function getAllMetrics(/* ... */) {
  try {
    const rows = await db.query(/* your join/select */);
    return Array.isArray(rows) ? rows : [];
  } catch (e) {
    // rethrow so controller can decide on cache/fallback
    throw e;
  }
}
```

**Client: show a non-blocking empty state**

```ts
const { data } = useQuery({ queryKey: ['/api/etf-metrics', { symbols }] });
const rows = Array.isArray(data) ? data : [];
// if rows.length === 0, show “No metrics (DB unavailable)” small badge, not an error modal
```

---

## C) Quick diagnostics you can run now

1. **Health check**

```
GET /api/health
// return { ok:true, db:true } or { ok:false, db:false, error:"…" }
```

2. **Direct metrics call**

* Look at server logs during `GET /api/etf-metrics` — what’s the first error line?

  * `ECONNREFUSED` → wrong host/URL
  * `self signed certificate` → add `ssl: { rejectUnauthorized:false }`
  * `connection timeout` → add `connectionTimeoutMillis`
  * `relation … does not exist` → run migrations

3. **Check your `DATABASE_URL` at runtime**
   Log it once masked:

```ts
const url = process.env.DATABASE_URL ?? '';
console.log('DB URL host:', url.split('@')[1]?.split('/')[0], 'sslmode:', url.includes('sslmode=require'));
```

---

## D) Optional: live fallback (so analysts still see something)

If DB is down but TwelveData is up, you can compute a **minimal** metrics table on the fly (price, 1D % change, 20D z‑score) and label it “Live (no DB)”. I can drop a helper for that if you want a graceful degraded mode.

---

### TL;DR

* Add TLS + timeouts + tiny pool to your `pg` client.
* Don’t crash on DB errors; cache the last good metrics and return `[]` when down.
* Ensure migrations exist if you see “relation does not exist”.

If you paste the first **error message** from your server log for `/api/etf-metrics`, I’ll point to the exact one‑liner (URL suffix vs SSL vs migrations).
