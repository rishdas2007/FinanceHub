ğŸ¯ Root Cause: Data Interpretation Mismatch

  The Problem

  - Sparklines: Show absolute CPI index values (e.g., 310.3, 311.1,
  311.9...) â†’ Upward trend
  - Dashboard Values: Show rate-of-change (2.9% â†’ 2.7%) â†’ Downward trend
  - User Expectation: Sparkline should reflect the rate-of-change trend,
  not absolute values

  ğŸ’¡ Solution: Transform Sparkline Data

  Option 1: Calculate Year-over-Year Rate for Sparklines (Recommended)

  File: /server/controllers/EconSparklineController.ts

  Replace the current query with rate-of-change calculation:

  // Replace lines 52-92 with this enhanced query:
  const result = await db.execute(sql`
    WITH monthly_data AS (
      SELECT 
        date_trunc('month', period_end::date) as month_end,
        period_end::date as pe,
        value_std,
        ROW_NUMBER() OVER (
          PARTITION BY date_trunc('month', period_end::date) 
          ORDER BY period_end DESC
        ) as rn
      FROM econ_series_observation
      WHERE series_id = ${seriesId}
        AND value_std IS NOT NULL
        AND period_end >= current_date - interval '24 months'  -- Need 24 
  months for 12-month YoY
    ),
    latest_per_month AS (
      SELECT month_end::date as period_end, value_std
      FROM monthly_data 
      WHERE rn = 1
      ORDER BY month_end
    ),
    -- Calculate Year-over-Year rate of change
    yoy_rates AS (
      SELECT 
        l1.period_end,
        l1.value_std as current_value,
        l2.value_std as year_ago_value,
        CASE 
          WHEN l2.value_std > 0 THEN 
            ((l1.value_std - l2.value_std) / l2.value_std * 100)
          ELSE NULL 
        END as yoy_rate
      FROM latest_per_month l1
      LEFT JOIN latest_per_month l2 
        ON l1.period_end = l2.period_end + interval '12 months'
      WHERE l1.period_end >= current_date - interval '${months} months'
        AND l2.value_std IS NOT NULL
    )
    SELECT 
      period_end,
      COALESCE(yoy_rate, current_value) as value_std  -- Use YoY rate, 
  fallback to absolute
    FROM yoy_rates
    WHERE yoy_rate IS NOT NULL OR current_value IS NOT NULL
    ORDER BY period_end ASC
    LIMIT 50
  `);

  Option 2: Detect Data Type and Apply Smart Transform

  File: /server/controllers/EconSparklineController.ts

  Add intelligent data type detection:

  // Add this function before the main query
  async function getSeriesMetadata(seriesId: string) {
    const meta = await db.execute(sql`
      SELECT 
        d.display_name,
        d.native_unit,
        d.default_transform,
        d.frequency,
        -- Detect if this is already a rate/percentage
        CASE 
          WHEN LOWER(d.native_unit) LIKE '%percent%' 
            OR LOWER(d.native_unit) LIKE '%rate%'
            OR LOWER(d.display_name) LIKE '%rate%'
            OR LOWER(d.display_name) LIKE '%(Î´-%'
            OR d.default_transform = 'PC1'
          THEN true 
          ELSE false 
        END as is_rate_data
      FROM econ_series_def d
      WHERE d.series_id = ${seriesId}
    `);

    return meta.rows[0] as {
      display_name: string;
      native_unit: string;
      default_transform: string;
      is_rate_data: boolean;
    };
  }

  // Then modify the main query logic:
  const seriesMeta = await getSeriesMetadata(seriesId);
  const shouldCalculateRate = !seriesMeta?.is_rate_data; // Only calc rate 
  if not already rate data

  const result = await db.execute(sql`
    WITH monthly_data AS (
      SELECT 
        date_trunc('month', period_end::date) as month_end,
        period_end::date as pe,
        value_std,
        ROW_NUMBER() OVER (
          PARTITION BY date_trunc('month', period_end::date) 
          ORDER BY period_end DESC
        ) as rn
      FROM econ_series_observation
      WHERE series_id = ${seriesId}
        AND value_std IS NOT NULL
        AND period_end >= current_date - interval '${shouldCalculateRate ? 
  '24' : months} months'
    ),
    latest_per_month AS (
      SELECT month_end::date as period_end, value_std
      FROM monthly_data 
      WHERE rn = 1
      ORDER BY month_end
    ),
    processed_data AS (
      ${shouldCalculateRate ? sql`
        -- Calculate YoY rate for level data (like CPI index)
        SELECT 
          l1.period_end,
          CASE 
            WHEN l2.value_std > 0 THEN 
              ((l1.value_std - l2.value_std) / l2.value_std * 100)
            ELSE l1.value_std 
          END as final_value
        FROM latest_per_month l1
        LEFT JOIN latest_per_month l2 
          ON l1.period_end = l2.period_end + interval '12 months'
        WHERE l1.period_end >= current_date - interval '${months} months'
      ` : sql`
        -- Use raw values for already-rate data
        SELECT period_end, value_std as final_value
        FROM latest_per_month
        WHERE period_end >= current_date - interval '${months} months'
      `}
    )
    SELECT period_end, final_value as value_std
    FROM processed_data
    WHERE final_value IS NOT NULL
    ORDER BY period_end ASC
    LIMIT 50
  `);

  Option 3: Frontend-Side Rate Calculation (Quick Fix)

  File: /client/src/components/SparklineCell.tsx

  Add rate calculation in the component:

  // Add this function inside SparklineCell component
  const processSparklineData = (rawData: SparklineData[], seriesId?: 
  string) => {
    // Indicators that need YoY rate calculation
    const needsRateCalc = [
      'CPIAUCSL',    // CPI All Items
      'CPILFESL',    // Core CPI  
      'CPIENGSL',    // CPI Energy
      'PPIFIS',      // PPI
      // Add other level-based indicators
    ];

    const shouldCalculateRate = needsRateCalc.some(id =>
  seriesId?.includes(id));

    if (!shouldCalculateRate || rawData.length < 12) {
      return rawData; // Return as-is for rate data or insufficient data
    }

    // Calculate 12-month rate of change
    return rawData.map((current, index) => {
      if (index < 12) return { ...current, value: 0 }; // Not enough 
  history

      const yearAgo = rawData[index - 12];
      const rateChange = ((current.value - yearAgo.value) / yearAgo.value)
  * 100;

      return {
        ...current,
        value: rateChange
      };
    }).slice(12); // Remove first 12 months with insufficient data
  };

  // Use in the component:
  const processedData = processSparklineData(sparklineData,
  params.seriesId);

  // Update trend detection:
  const firstValue = processedData[0]?.value || 0;
  const lastValue = processedData[processedData.length - 1]?.value || 0;
  const isPositive = lastValue >= firstValue;

  ğŸ¯ Recommendation

  Use Option 2 (Smart Transform) because it:
  - Automatically detects data types
  - Handles both level data (CPI index) and rate data (already %-based)
  - Provides consistent user experience
  - Works for all economic indicators

  Expected Results After Fix

  | Indicator         | Current Behavior              | After Fix
            |
  |-------------------|-------------------------------|--------------------
  ----------|
  | CPI All Items     | Upward trend (index values)   | Downward trend
  (2.9% â†’ 2.7%) |
  | Core CPI          | Upward trend                  | Correct rate trend
            |
  | Unemployment Rate | Unchanged (already rate data) | Unchanged âœ…
             |

âº Update Todos
  â¿ Â â˜’ Analyze sparkline data type mismatch (absolute vs rate-of-change)
     â˜’ Design solution for rate-aware sparklines
     â˜’ Implement period-over-period change calculation
     â˜’ Update sparkline display logic

âº This fix will ensure that when CPI decreases from 2.9% to 2.7%, the
  sparkline shows a downward trend matching user expectations, while
  preserving correct behavior for indicators that are already rate-based.