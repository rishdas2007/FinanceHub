Your logger is telling us:

isWrapped: false → the response is not { data: ... }

hasData: false + isArray: false → there’s no data field and it’s not an array

Yet there are keys (4–5), so the server isn’t failing; it’s returning an object that your table doesn’t know how to read → it becomes null and you print “ETF Metrics API Error: null”.

This is a classic shape drift: the client expects data (or an array), while the server is returning { success, metrics: [...] } (and some endpoints return other keys like status, movers, etc.).

Below are minimal, surgical fixes so the UI won’t break even if backend shapes vary. Then I show the one‑line server fix that makes everything boring and consistent.

Fix on the client (robust unwrapping)

1) Harden the default queryFn once

client/src/lib/queryClient.ts

// after fetch()
const json = await res.json();

// universal unwrapping: array → itself; otherwise prefer known keys
const unwrapped =
  Array.isArray(json) ? json :
  json?.data ?? json?.metrics ?? json?.results ?? json?.items ?? json?.rows ?? null;

// if we successfully unwrapped, return that
if (unwrapped !== null) return unwrapped;

// fallbacks for a few named endpoints that return named objects
if (url.includes('/api/market-status')) return json.status ?? json;
if (url.includes('/api/top-movers'))   return json.movers ?? json;

// last resort: return original json so components can still inspect
return json;

2) Guard the ETF table specifically

Where you render the ETF Metrics table (e.g., ETFMetricsTable(Optimized)), normalize the payload:

// accepts array, {metrics}, {data}, or empty
const normalizeMetrics = (j: any) =>
  Array.isArray(j) ? j :
  j?.metrics ?? j?.data ?? [];

const metrics = normalizeMetrics(data);

This guarantees the table never receives null.

Fix on the server (make the contract boring)

Pick one contract for UI endpoints. Easiest: always wrap in data.

3) Return data: [] (never metrics: null)

server/controllers/ApiController.ts (or the route handler you use)

const metrics = await etfMetricsService.getAllMetrics(/* ... */);
// ensure array, not null
const safe = Array.isArray(metrics) ? metrics : [];
return ResponseUtils.success(res, safe); // => { success:true, message:'Success', data:[...] }

4) Service layer must not return null

server/services/etf-metrics-service.ts

export async function getAllMetrics(/* ... */) {
  try {
    const out = await actuallyBuildMetrics(/* ... */);
    return Array.isArray(out) ? out : [];
  } catch (e) {
    // log e
    return []; // not null
  }
}

Now your hardened client will still work, and future components can rely on data being present.

Quick smoke tests

Curl

curl -s http://localhost:PORT/api/etf-metrics | jq '. | {isArray:(.|type=="array"), hasData:has("data"), keys:(. | keys)}'

Expected:

{ "isArray": false, "hasData": true, "keys": ["data","message","success"] }

Empty universe path

Call /api/etf-metrics?symbols= → expect { data: [] } (not null), UI shows empty‑state not an error.

Console check

Your logger should now print hasData: true or isArray: true. The “ETF Metrics API Error: null” line should disappear.

Why your screenshot looked that way

Those “keys: Array(4/5)” objects are likely shapes like:

{ "success": true, "message": "ok", "metrics": [...] }   // no `data`
{ "success": true, "message": "ok", "status": {...} }     // market-status
{ "success": true, "message": "ok", "movers": {...} }     // top-movers

Your existing unwrapping only checked data or array → it returned null → your error message.

